---
timezone: UTC+8
---

# 成默

**GitHub ID:** slucifersz

**Telegram:** @LuciferNebuchadnezar  微信

## Self-introduction

大家好

## Notes

<!-- Content_START -->
# 2025-08-11

Web3 社区运营笔记

1. 核心职责
日常内容与社群维护

   定期更新社媒（Twitter、公众号等）
   维护社群秩序：答疑、禁言、反垃圾信息
   设计话题引导讨论

* **内容发布与互动引导**

  * 活动预热、AMA 宣传、开播提醒
  * 推送与品牌调性相关的内容，多渠道同步

* **活动策划与组织**

  * 线上：Twitter Space、线上课程、黑客松
  * 线下：Meetup、Workshop、论坛等
  * 前期策划 → 活动中执行 → 活动后总结

* **对外合作与社区联动**

  * 联合 AMA/活动
  * 与 KOL、媒体保持沟通，争取转发与报道

---

## 2. 常用工具与平台

### 社交媒体渠道

* **Twitter (X)**：核心信息与活动传播
* **微信公众号**：中文市场推广
* **Medium/Substack**：长文、理念与进展发布

### 社群沟通

* **Discord**：主阵地，频道+Bot管理
* **Telegram**：AMA、轻量用户支持
* **微信群**：中国区常用

### 内容创作

* **Notion/Notion AI**：文档与活动计划
* **ChatGPT**：文案与翻译
* **Figma/Canva**：海报设计
* **Tally/Typeform**：报名表与问卷

### 数据与行业分析

* **Etherscan**：链上交易与合约查看
* **Dune Analytics**：SQL 数据分析
* **CoinGecko / CMC**：币价与项目信息
* **Token Terminal**：财务与增长数据

---

## 3. 线上活动执行（Twitter Space 模板）

**准备阶段**

* **T-5 \~ T-4 天**：确定主题、嘉宾、主持人、问题库 → 邀约嘉宾 → 收集嘉宾信息 → 制作海报+文案
* **T-4 \~ T-2 天**：第一波宣发（Twitter+TG+微信群），邀请嘉宾转发
* **T-1 天 \~ 当天**：第二波预热，临场提醒嘉宾和社区

**活动中**

* 开场：项目与嘉宾介绍
* 主题讨论（按问题库进行）
* 观众提问（奖励可吸引参与）

**活动后（T+7 内）**

* 数据复盘（浏览量、收听量、粉丝增长）
* 总结优化点（嘉宾确认效率、宣发节奏等）

---

## 4. 线下活动策划与执行

**策划阶段（4-5 周前）**

* 确定主题与形式（Keynote、Panel、Workshop 等）
* 明确目标与受众（开发者、DAO 成员等）
* 制定预算与分工（场地、差旅、物料、宣传）
* 法律与合规检查

**筹备阶段（2-4 周前）**

* 制定活动 Agenda
* 嘉宾邀请与信息收集（Deadline 控制）
* 宣传物料（倒计时海报、场地导引图等）
* 媒体/社区联动（Luma、ETHGlobal、SeeDAO）
* 周边制作与物流

**现场执行**

* 提前 2 小时完成场地布置+设备调试
* 嘉宾接待与签到引导
* 模块负责人分工明确，应急联系人群

**复盘阶段（1 周内）**

* Recap 内容产出（推特 thread、公众号、短视频）
* 数据对比（到场 vs 注册、曝光量、互动量）
* 成功与优化项总结，记录合作机会

---

## 5. 快速复盘重点

* **内容更新 + 社群活跃** 是日常运营基石
* **宣发节奏** 决定活动效果（建议至少两波）
* **多渠道协作**（KOL+媒体+合作社区）能显著扩大影响
* **数据复盘** 是迭代的关键，留存具体数字与反馈

---

如果你愿意，我可以帮你基于这份笔记直接做一份 **可打印的 Web3 社区运营流程图**，方便在执行时随时对照。这样能把复杂流程一步步视觉化，减少遗漏。

# 2025-08-10

### 概念解析报告：堆栈（Stack）  
*——计算机科学中最高效的LIFO（后进先出）抽象数据类型*

---

#### 1. 技术范畴与历史定位
- **技术范畴**：线性数据结构 → 受限序列操作（ADT）→ 运行时内存管理基础  
- **历史演进**：
  - 1946年：Alan Turing首次提出"返回地址存储"概念（堆栈雏形）  
  - 1957年：Friedrich L. Bauer和Klaus Samelson正式定义堆栈ADT  
  - 1960年：ALGOL 60首次实现编程语言级堆栈支持  
  - 1980年：Intel 8086处理器集成硬件堆栈指针寄存器(SP)  

#### 2. 分层解析（三层架构）
| 层级        | 核心原理                          | 实现示例                  |
|-------------|---------------------------------|-------------------------|
| **基础层**  | LIFO原则（后进先出）              | 数学归纳法证明操作正确性    |
| **实现层**  | 物理结构：数组（静态）或链表（动态） | Java Stack类 / Python list |
|             | 核心操作：push(), pop(), peek()   | x86汇编的PUSH/POP指令     |
| **应用层**  | 函数调用栈 / 表达式求值 / 回溯算法 | JVM栈帧 / 浏览器后退按钮  |

---

#### 3. 多维度对比
| 维度          | 堆栈(Stack)                  | 队列(Queue)               | 堆(Heap)                 |
|---------------|-----------------------------|--------------------------|--------------------------|
| **访问规则**  | LIFO（后进先出）             | FIFO（先进先出）          | 优先级驱动               |
| **核心操作**  | push/pop (O(1))            | enqueue/dequeue (O(1))   | insert/extractMin (O(log n)) |
| **典型应用**  | 函数调用链                  | 消息缓冲队列              | 优先任务调度             |
| **内存布局**  | 连续内存（通常）            | 可分段存储               | 树状结构存储             |

---

#### 4. 现实应用案例
**案例1：程序运行时栈**  
- *问题*：函数嵌套调用需保存返回地址与局部变量  
- *方案*：编译器自动生成栈帧管理指令  
- *实例*：C语言函数调用时自动压入参数、返回地址、基指针  
```c
int factorial(int n) {
    if(n <= 1) return 1;       // 递归基栈帧深度=1
    return n * factorial(n-1); // 每层递归新增栈帧
}  // 当n=1000时可能引发栈溢出(Stack Overflow)
```

**案例2：深度优先搜索(DFS)**  
- *问题*：图遍历需记录未探索节点  
- *方案*：堆栈存储待访问节点  
- *实例*：迷宫求解路径回溯  
```python
def dfs(maze, start):
    stack = [start]            # 初始化堆栈
    while stack:
        node = stack.pop()     # LIFO特性实现回溯
        if node == exit: return path
        for neighbor in get_neighbors(node):
            stack.push(neighbor)  # 新节点入栈
```

---

#### 5. 常见误区警示
**误区1**："堆栈是Java的Stack类"  
- *事实*：Stack是ADT的具体实现，不同语言有差异实现（如C++用deque）  
- *关键区分*：ADT定义操作规范，实现类提供具体性能特性  

**误区2**："递归总能用堆栈替代"  
- *限制*：尾递归可直接优化为循环，非尾递归需显式维护栈  
- *反例*：树的前序遍历递归版更易读，显式栈版本代码更复杂  
```java
// 非尾递归的栈替代方案（增加复杂度）
void preorder(TreeNode root) {
    Stack<TreeNode> stack = new Stack<>();
    while (root != null || !stack.empty()) {
        while (root != null) {
            visit(root);          // 先访问再入栈
            stack.push(root);
            root = root.left;
        }
        root = stack.pop().right;
    }
}
```

---

#### 6. 知识链关联
```mermaid
graph LR
A[堆栈ADT] --> B[内存管理]
A --> C[编译器设计]
A --> D[算法范式]
B --> E[栈帧结构与指针]
B --> F[缓冲区溢出攻击]
C --> G[语法解析器(LR算法)]
D --> H[回溯/DFS/表达式求值]
```

---

#### 7. 进阶学习路径
1. **理论基础**：  
   - 《Data Structures and Algorithm Analysis》第3章（栈与队列ADT）  
   - IEEE标准：ISO/IEC 30112《数据结构使用规范》  
2. **实现剖析**：  
   - Linux内核进程内核栈（struct thread_info）  
   - JVM栈帧结构（局部变量表/操作数栈）  
3. **前沿方向**：  
   - 并发栈实现（Treiber Stack vs. Elimination Backoff Stack）  
   - 硬件辅助栈管理（ARM v8.3的指针认证PAC）  

> 堆栈作为计算机系统的"时空胶囊"，既保存着程序执行的瞬时状态（函数调用栈），又承载着算法回溯的历史记忆（DFS）。理解其LIFO本质是掌握运行时内存管理的基石。下一步建议延伸解析**堆(Heap)内存管理**或**尾调用优化(TCO)** 相关概念。

# 2025-08-09

Uniswap V3 与 V4 深度解析：集中流动性与挂钩合约
 Uniswap ——V3 和 V4。

在传统金融市场，所有交易都发生在一个中心化的场所，有订单簿来撮合买卖双方。但在 DeFi 世界，Uniswap 这样的 DEX 使用的是 自动做市商（AMM） 模型。简单来说，就是你不是和另一个人交易，而是和链上的一个“流动性池”进行交易。池子里有两种代币，智能合约根据池子里两种代币的比例来确定价格。

★ Uniswap V3: 集中流动性 (Concentrated Liquidity) 的革命
我们先回顾一下 Uniswap V2 的痛点。在 V2 中，当你向一个 ETH/USDT 资金池提供流动性时，你的资金会被平均分配到所有可能的价格区间，从0到无穷大。

【类比解释：从“大卖场”到“精品店”】
想象一下，你开了一家24小时营业的便利店，里面同时卖可乐和薯片。

V2 模式就像是你在店里每个角落、每个货架上都放了一点可乐和薯片，甚至包括那些顾客永远不会去的地方（比如天花板上或地底下）。你的资金（商品）铺得很广，但只有一小部分在最常被交易的价格（当前价格）附近发挥作用。大部分资金都闲置着，效率很低。

V3 模式彻底改变了这一点。它允许你指定一个自定义的价格区间来提供流动性。比如，你觉得 ETH 的价格会在 $3000 到 $3200 之间波动，你就可以把你的 ETH 和 USDT 只放在这个价格区间内。

V3 带来的核心优势（也就是为什么它被称为“集中流动性”）:

资金效率大幅提升 (Capital Efficiency)：

在 V2 中，你可能需要投入 100 万美元的流动性才能获得 X 收益。

在 V3 中，你可能只需要投入 10 万美元，就能在指定的价格区间内获得相同的甚至更高的 X 收益，因为你的资金被“集中”利用了。这就像你的“精品店”只卖最热门的商品，把所有精力都放在了刀刃上。

【示例】 如果 ETH 价格是 $3100，你在 $3000-$3200 提供的流动性会非常活跃地参与交易，赚取手续费。而如果你在 $100-$200 的区间也提供了流动性，这部分资金几乎永远不会被用到。V3 让你避免了这种浪费。

LP 收益增加 (Higher LP Fees)：

由于你的资金利用效率更高，它在相同的交易量下能捕获更多交易手续费。

V3 还引入了多层手续费机制 (Multiple Fee Tiers)，针对不同波动性的交易对（如稳定币之间、ETH/USDT 等），允许流动性提供者选择不同的手续费率（例如 0.05%、0.3%、1%），从而更精准地定价风险和收益。

【无常损失的加剧与应对】
★ 无常损失 (Impermanent Loss)：虽然 V3 提高了资金效率，但也可能加剧无常损失。

原因： 如果资产价格剧烈波动，超出了你设定的集中区间，你的流动性就会变得“不活跃”，完全变成单一资产（例如，如果 ETH 涨到 $3500，你区间内的所有 USDT 都卖掉了，你的流动性就全部是 ETH 了）。在这种情况下，你就无法继续赚取手续费，而且如果价格没有回到你设定的区间，你的总价值可能低于简单持有这两种资产。

应对： V3 LP 需要更频繁地主动管理他们的头寸，根据市场价格变化调整（rebalance）他们的流动性区间，以保持活跃并赚取手续费。这要求 LP 具备一定的市场判断能力和操作频率。

★ Uniswap V4: 挂钩合约 (Hooks) - 拓展无限可能
如果说 V3 改变了“售货员”摆放商品的方式，那么 Uniswap V4 的核心创新“挂钩合约（Hooks）”则是在售货机的内部结构上做了颠覆性的改变。

【类比解释：从“固定功能手机”到“高度可定制的智能操作系统”】

Uniswap V3 就像一个功能强大的智能手机，它自带了优秀的功能，比如集中流动性。但它的核心逻辑是固定的。

Uniswap V4 就像一个高度可定制的智能手机操作系统，它开放了底层的接口。这意味着，你可以在这个操作系统的任何关键环节（比如应用程序启动前、支付完成后）插入你自定义的“小程序”或“插件”。

Hooks 的运作原理：

Hooks 允许开发者在 Uniswap 资金池的生命周期中的特定“挂钩点”执行自定义代码。这些挂钩点包括但不限于：

beforeInitialize: 资金池初始化前

afterInitialize: 资金池初始化后

beforeModifyPosition: 修改 LP 头寸前（如增加/移除流动性）

afterModifyPosition: 修改 LP 头寸后

beforeSwap: 交易发生前

afterSwap: 交易发生后

V4 挂钩合约带来的巨大潜力：

动态手续费 (Dynamic Fees)：

通过 beforeSwap 或 afterSwap Hook，可以实现根据市场波动性、交易量、甚至是特定代币的风险程度，实时调整交易手续费。比如，市场波动大时自动提高手续费，以补偿 LP 的无常损失风险。

链上限价单 (On-chain Limit Orders)：

LP 可以通过 Hook 编写逻辑，当价格达到某个预设值时，自动添加或移除流动性，从而实现更高级的交易策略，类似于传统订单簿的限价单。

自动复利 (Auto-compounding)：

通过 Hook，可以实现将赚取的手续费自动再投资回流动性池，从而省去了 LP 手动操作的麻烦，实现复利增长。

定制化 LP 策略 (Customized LP Strategies)：

Hooks 可以实现更复杂的 LP 策略，例如：

时间加权平均价格 (TWAP)：内置 TWAP 预言机。

MEV 保护：通过 Hook 来降低或消除矿工可提取价值（MEV）对交易的负面影响。

任意代币交换逻辑：例如，支持在交易前或交易后进行额外的代币操作。

【重要提醒与风险】
Uniswap V4 的 Hooks 概念潜力巨大，但它也意味着更高的复杂性和潜在的安全风险。由于允许开发者插入任意代码，如果 Hook 合约本身存在漏洞，可能会影响整个资金池的安全。目前 V4 仍处于开发阶段，尚未上线主网，它的实际表现和安全性还需要时间来验证。

通过这次更详细的讲解，相信你对 Uniswap V3 的“集中流动性”如何提高资金效率，以及 Uniswap V4 的“Hooks”如何为 DeFi 创新打开无限可能有了更深刻的理解。

总结一下：

V3 优化了流动性的分配方式，让 LP 的资金更有效率地赚取手续费。

V4 提供了高度的可定制性，允许开发者在协议核心逻辑中加入自定义功能。

现在，我们再来思考一下这个场景题，并加上 V4 的思考：

假设你是一个流动性提供者（LP），在 ETH/USDT 交易对中，你认为未来 ETH 的价格会围绕 3000 美元到 3200 美元之间小幅波动。

如果你使用 Uniswap V3，你会如何设置你的流动性区间？这样做的好处是什么？主要风险又是什么？

如果未来 Uniswap V4 上线并稳定运行，你觉得 Hooks 功能可以如何帮助你更自动化地管理你的这个 ETH/USDT 流动性头寸，从而可能规避 V3 的某个风险？

# 2025-08-08

一、去中心化与高性能
❖ 问题本质：
•  去中心化优先：如果公链的核心目标是作为全球信任层和价值结算网络，那么去中心化和安全性是不可妥协的。这确保了网络的抗审查性、不可篡改性以及对任何单一实体的独立性。在这种模式下，性能通常会受到牺牲，例如每秒交易量（TPS）较低。
•  高性能优先：如果公链的目标是支持大规模应用（DApps），特别是需要高频交易和低延迟的场景，如游戏、社交或DeFi，那么高性能和可扩展性会成为首要任务。这通常意味着需要牺牲一定程度的去中心化，例如通过减少验证节点的数量或采用更中心化的共识机制。

❖ 分析：
维度	去中心化优先	高性能优先
代表公链	以太坊、Bitcoin	Solana、Aptos、Sui
网络结构	节点分布广，运行门槛低	超节点机制，运行门槛高
安全性	更抗审查，安全性强	高性能带来潜在攻击面
可用性	TPS低、gas高峰期拥堵	高TPS、低延迟
社区信任	更易获得“真正Web3用户”的信任	吸引Web2开发者迁移
❖ 判断：
•	初期阶段（冷启动）：适度牺牲去中心化换取可用性与开发者生态（见 Solana）。
•	中长期演进：应回归“模块化”架构（见 Celestia），通过**分层设计（如Layer2）**实现性能而不牺牲核心去中心化价值。
•	最终目标：以去中心化为锚，性能作为迭代路径，而非初期妥协的底线。
❖ 真实事例：
•	以太坊：PoW → PoS + Rollups（L2）实现性能提升而保留去中心化。
•	Solana：为高性能牺牲部分去中心化（超高性能节点要求），在停机事件中饱受批评（2022年多次宕机）。
________________________________________
二、公链的治理模型对比：链上 vs 链下 vs 混合
•  链上治理（On-chain Governance）：
•	特点：治理规则（如提案、投票、执行）直接编码在区块链协议中，通常通过代币投票或多签钱包等方式进行。
•	优点：流程透明、自动化程度高，可以快速执行决策。参与者的激励与链上资产直接挂钩，理论上能促进更积极的参与。
•	缺点：可能导致**“富豪统治”**（Plutocracy），即持有大量代币的巨鲸用户能主导投票结果。此外，治理过程可能缺乏深度讨论和思辨，导致决策草率。
•  链下治理（Off-chain Governance）：
•	特点：决策过程发生在链下，如通过社区论坛、社交媒体、开发者会议等进行讨论，最终通过软分叉或硬分叉来更新协议。
•	优点：更加灵活、开放，允许更广泛的社区参与，包括非代币持有者。决策过程可以进行更充分的讨论和评估。
•	缺点：决策周期长、效率低，并且最终的执行依赖于社区共识，如果无法达成一致可能导致分裂。

❖ 模型概览：
模型类型	代表项目	特点与机制
链下治理	比特币、早期以太坊	社区共识驱动，无正式投票机制，慢但稳定
链上治理	Polkadot、Tezos	提案 + 代币投票，自动执行升级，有透明记录但易受鲸鱼操控
混合治理	Ethereum (现阶段)、Arbitrum DAO	社区论坛讨论 + Snapshot投票 + 多签执行，兼顾效率与安全
❖ 模型对比：
维度	链下治理	链上治理	混合治理
决策效率	低	高（可自动执行）	中等
去中心化	高	取决于代币分布	依赖多签机制和论坛机制
安全性	高（人为把控）	易遭治理攻击（如投票劫持）	多重保护机制
社区参与	依赖自发行动	代币驱动	多渠道鼓励参与
容易作恶	难	容易（持币即权力）	需多方联合作恶，门槛更高
❖ 判断：
•	冷启动阶段：推荐混合治理（如Snapshot + 多签），便于社区协商和风险控制。
•	成熟生态后：逐步引入链上治理组件，但必须配合防治“治理寡头化”机制（如 Quadratic Voting）。
❖ 真实事例：
•	Polkadot链上治理高度结构化，但遭遇代币权重过高问题。
•	Arbitrum DAO启动初期因未经授权转移资金（7亿ARB）引发治理危机，被社区强烈反对，后修正流程、设立“透明度委员会”。
________________________________________
三、应该优先激励谁？用户 vs 开发者？
•  早期阶段：优先激励开发者
•	原因：在公链生态的初期，缺乏应用和基础设施是主要瓶颈。吸引开发者构建高质量的DApps、钱包、工具等是当务之急。只有拥有丰富的应用生态，才能吸引真实的用户。
•  成熟阶段：优先激励用户
•	原因：当公链生态已初具规模，拥有一定数量的应用后，用户增长成为新的重点。通过空投、流动性挖矿、交易奖励等方式激励用户参与，可以形成网络效应，增强生态的活力和韧性。

❖ 分析逻辑：
维度	激励用户	激励开发者
目的	提升活跃度，扩大链上数据和交易规模	丰富生态应用，提升长期价值
手段	空投、交易返佣、NFT激励等	建设者基金、Grants、黑客松、代币奖励
易错方向	群体“薅羊毛”，不留下忠实用户	资金滥用，开发者“撸完即走”
建议策略	精准空投（如Lens/zkSync）	区分短期激励和长期建设（如Gitcoin评审）
❖ 判断：
开发者应为首要激励对象，用户为后期生态成熟后的放大器。
理由如下：
•	初期无产品可用，用户激励难形成留存。
•	激励开发者构建真实Dapp，才能创造用户真正需求。
•	优质开发者的持续建设性贡献，会创造真实“使用场景”，而非“搬砖套利”。
❖ 真实事例：
•	Optimism推出RetroPGF（Retroactive Public Goods Funding），以过去影响力决定激励，真正鼓励长期生态建设。
•	Arbitrum基金会设立数亿美元基金，支持开发者生态而非直接补贴用户。
________________________________________
四、资金管理如何增强用户信任？
公链如何管理资金来获取用户信任？
资金的透明、高效管理是公链生态健康发展和赢得社区信任的基石。缺乏透明度可能导致资金滥用和社区分裂。
分析与判断
•	资金管理核心：将决策权从中心化实体转移至社区。
•	关键机制：
o	多重签名（Multi-signature）钱包：将关键资金的控制权分散给多个受信任的个人或实体，任何资金动用都需要其中多方共同签名。这显著降低了单点故障和资金滥用的风险。
o	DAO（去中心化自治组织）治理：将资金管理权完全交给社区，由代币持有者通过链上投票决定资金的使用。这实现了最高的透明度和去中心化，但可能面临决策效率低下的挑战。
❖ 目标：
•	防范贪污与资金滥用
•	提升社区信心
•	保障公共财政长期运作
❖ 可选机制：
机制类型	特点	风险点
多签钱包（Gnosis Safe）	需多个地址共同签署，防止单点作恶	多签人“合谋”风险，操作效率低
DAO投票控制资金分配	社区决定资金流向，去中心化透明	投票率低，资金被鲸鱼控制
审计机制	公布季度财务审计报告、链上支出透明	审计滞后、成本高
实时支出仪表盘	如Aragon/OpenGov，所有支出一目了然	前期开发复杂度高，但长期稳定性高
❖ 判断：
推荐采用以下组合方案：
1.	多签钱包 + 公示仪表盘（透明支出）（初期）
2.	引入DAO治理投票 + 独立审计机构报告（中期）
3.	结合ZKP等技术实现隐私保护的支出可验证性（前沿）
❖ 真实事例：
•	Optimism基金会在支出方面定期发布报告并开源治理文件。
•	Gitcoin Grants引入社区评审与捐赠透明榜单，提升透明度。
________________________________________

# 2025-08-07

可以用智能合约部署mint
部署成功后，我们可以借助 Etherscan （已默认选择测试网）区块浏览器 对部署过程及合约状态进行进一步验证与分析。
初始化连接：前端检测并连接 Web3 提供者
用户授权：请求用户授权访问钱包账户
合约实例化：使用 ABI 和合约地址创建合约实例
函数调用：通过合约实例调用智能合约函数
交易签名：钱包对交易进行数字签名
广播交易：将签名交易发送到区块链网络
状态更新：获取交易结果并更新前端界面
合约语言： 掌握 Solidity 等相关合约开发语言
Web3.js/Ethers.js： JavaScript 库，提供区块链交互 API (当前 Web3.js/Ethers.js 库比较老旧，本技术只用来学习理解整体流程，可以使用 Viem、Wagmi 进行新项目开发)
钱包连接器：如 RainbowKit、ConnectKit、WalletConnect、Web3Modal 等
状态管理：React Context 等管理连接状态
错误处理：网络异常、用户拒绝、Gas 不足等场景处理

# 2025-08-06

Dapp 的核心特点在于去中心化，意味着应用的逻辑和数据不由单一实体控制，而是由多个参与者共同维护。

智能合约（比如一个 NFT 合约）在执行某些操作（比如转账 NFT）时，会释放事件（Event）。这就好像它在说：“我刚刚做了一件事，请关注我！”
数据检索器（Indexer）就是一个在后台运行的服务，专门做这件事：

💡 自动监听智能合约释放的事件（比如 Transfer 事件），然后把这些事件整理、处理后，存入传统数据库（如 PostgreSQL）中，方便前端快速查询。
在群聊中看到老师推荐了很多课，准备学习

# 2025-08-05

外部账户（EOA）合约账户（CA
DeFi，全称为 Decentralized Finance（去中心化金融）
交易后 x * y ≠ k，套利者就能不断从中获利，直到池子亏空。
DAO（Decentralized Autonomous Organization，去中心化自治组织），不依赖传统的公司架构，而是通过智能合约和社区投票来做决策。它不需要一个管理层，所有事情都由持有代币的社区成员共同治理，公开透明，没有什么事情可以背着大家，尤其是利益分配相关的问题。
关注链上数据透明度

项目方是否公开代币分配、核心地址信息？如果代币高度集中，可能会被少数大户操控价格，导致投资者亏损。
DAO（Decentralized Autonomous Organization，去中心化自治组织）

# 2025-08-04

区块链是一种去中心化的分布式账本技术。
每个区块包含交易数据 + 上一个区块的哈希值，依时间顺序链接成链。
不可篡改、公开透明、交易快速。
争夺账本的记录权可以获得奖励
去中心化-自由平等 未来


# 2025.08.01


<!-- Content_END -->
