---
timezone: UTC+8
---

# Elorze

**GitHub ID:** Elorze

**Telegram:** @Elorze

## Self-introduction

充满好奇心，保持热情

## Notes

<!-- Content_START -->
# 2025-08-06

今天参加了MARCUS老师的分享会，听了故事。很多名词还不是很明白，打算之后慢慢了解。
比较有感触的记一条笔记： 

DPoS的治理危机在于“过度中心化”，主要表现为：

少数节点权力过大：少数超级节点掌握了网络运营和治理的绝大部分权力。
投票权集中：代币量决定投票权，大户可操控选举，形成“富者愈富”。
串谋寻租风险：少数节点间可能串通，利用权力谋取私利。
普通用户参与度低：多数用户不参与投票，使治理权更集中。

做了 https://unphishable.io/challenges/fake-extension-phishing 钓鱼挑战的beginner部分。学习到了很多，巩固了昨天讲座上的内容。

# 2025-08-05

今天阅读了手册的 【行业全览】和【工作方式】。在远程协作习惯这节收获颇多。
在 https://cloud.google.com/application/web3/faucet/ethereum/sepolia 上领取了测试币，部署了safe account，向同学转账，[userOperation hash]: 0x10136f27b999df74536d31e55cf9860a09e8dff9108c7fc1542185d55b8d365a。

# 2025-08-04

今天看了文档的第一第二篇。

## 比特币为什么不会通胀？

核心原因是它的**总量被死死固定了，而且 “印钱” 速度越来越慢，绝不会多印**。

1. **总量有限，就那么多**比特币的白皮书（类似设计说明书）规定：**总共只能有 2100 万个比特币**，多一个都不会有。就像世界上黄金总量有限，挖完就没了，比特币 “挖” 到 2100 万个后，再也不会新增，所以不会像纸币那样被无限印刷。
2. **“印钱” 速度固定且递减，不会突然变多**比特币是通过 “挖矿” 产生的，但产量不是随便定的：
    - 刚开始，每 10 分钟能挖出 50 个比特币；
    - 每过 4 年，产量就会减半（比如从 50 个减到 25 个，再减到 12.5 个……）；
    - 按照这个规则，大约到 2140 年，2100 万个比特币就会被全挖出来，之后再也没有新的比特币产生。
    
    这种 “固定且递减” 的产出规则，保证了比特币不会像法币（比如人民币、美元）那样，因为央行随意印钱而导致总量暴增，自然就不会出现通胀。
    

## **2140 年后的比特币会怎样？**

2140 年并非比特币的 “终点”，而是其进化的新起点：

### **1. 完全依赖手续费的经济模型**

当最后一枚比特币被挖出后，矿工收入将**100% 来自交易手续费**。此时，手续费的定价机制将更加市场化 —— 用户为了加速交易确认，会主动支付更高费用，而矿工则优先打包高手续费交易。这种 “按需付费” 模式在互联网服务（如快递加急、云存储）中已被验证可行。

### **2. 网络安全性的质变**

随着比特币价值持续增长，攻击网络的成本将呈指数级上升。例如，2025 年攻击比特币网络需投入数百亿美元算力，而到 2140 年，这一成本可能达到天文数字。同时，**量子计算威胁**（如 Shor 算法破解椭圆曲线加密）也会被抗量子加密技术（如 BIP-360）逐步化解，确保网络长期安全。

### **3. 从货币到基础设施的进化**

比特币可能从单一货币形态演变为**全球金融基础设施**。例如，闪电网络已实现秒级跨境支付，而 Stacks 等侧链技术支持智能合约开发。这些创新将拓展比特币的应用场景，吸引更多企业和个人使用，进而增加链上交易需求，形成 “使用量增加→手续费增长→矿工积极性提升” 的良性循环。

## **RDF：给数据关系 “搭骨架”**

RDF（资源描述框架）的核心是用一种**简单统一的格式**描述 “谁和谁有什么关系”，就像给数据的关系画 “主谓宾” 句子。

它的基本结构是 “三元组”：**主体（谁）+ 谓词（什么关系）+ 客体（和谁）**。比如：

- 主体：苹果
- 谓词：属于
- 客体：水果

用这种结构，不管是中文、英文还是其他数据，都能统一成 “骨架”。比如 “Apple is a fruit”，在 RDF 里就是：主体：Apple谓词：is a客体：fruit

这样一来，电脑至少能明确：“苹果” 和 “水果” 有 “属于” 关系，“Apple” 和 “fruit” 有 “is a” 关系 —— 先把关系结构化，方便后续统一理解。

## **OWL：给数据关系 “定规则”**

光有骨架还不够。比如电脑知道 “苹果属于水果”“香蕉属于水果”，但它不知道 “水果都能吃”—— 这时候就需要 OWL（Web 本体语言）来补全 “逻辑规则”。

OWL 相当于给数据关系建一个 “知识框架”，定义更复杂的分类、属性和推理规则。比如：

1. **定义分类**：“水果是植物的果实，且可以直接食用”；“苹果、香蕉都是水果的子类”。
2. **定义属性**：“能吃” 是 “水果” 的必备属性（所有水果都能吃）。
3. **定义推理规则**：如果 “X 属于水果”，那么 “X 能吃”。

有了 OWL 的规则，电脑就能像人一样 “推理” 了：

- 已知 “苹果属于水果”（RDF 描述的关系），
- 加上 OWL 规则 “水果都能吃”，
- 电脑就能自动得出 “苹果能吃”—— 这就是智能理解的过程。

了解了pow和pos的区别。pos确实环保许多，对象参与的普通人更友好……


# 2025.07.30


<!-- Content_END -->
