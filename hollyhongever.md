---
timezone: UTC+8
---

# Green

**GitHub ID:** hollyhongever

**Telegram:** @hoooowoooo

## Self-introduction

东南大学法学本科毕业，已获法律职业资格证。浙江大学网安专硕研0，Web3 中白，目前在做稳定币合规方向的研究。

## Notes

<!-- Content_START -->
# 2025-08-06

学点固态（乐

部署合约其实就是发送一个交易，我们在区块链上做任何事情，修改任何状态，就是在发送一个交易。部署一个合约就修改了区块链，让链上拥有这个合约，如果我们在`Sepolia`，`Goerli`或者以太坊主网上发送这个交易，我们要支付`gas`来部署合约。

# 状态变量（State Variable）vs 局部变量（Local Variable）
| **特征**     | **状态变量（State Variables）**              | **局部变量（Local Variables）**                  |
| ---------- | -------------------------------------- | ------------------------------------------ |
| **存储位置**   | 永久存储在区块链的**存储（Storage）**中，占用链上空间。      | 临时存储在**内存（Memory）**或**栈（Stack）**中，不占用链上空间。 |
| **生命周期**   | 与合约生命周期一致，数据永久保存。                      | 仅在函数执行期间存在，函数结束后销毁。                        |
| **可见性**    | 可被合约内外访问（取决于修饰符 `public`/`private` 等）。 | 仅在定义它们的函数或代码块内可见。                          |
| **Gas 消耗** | 读写操作消耗较高 Gas（修改链上状态）。                  | 仅消耗计算 Gas（临时操作），成本极低。                      |
| **初始化**    | 必须显式初始化（声明时或构造函数中）。在合约部署时会被自动赋予默认值。    | 可不初始化，但推荐赋初值以避免意外行为。需开发者手动初始化。             |
|            |                                        |                                            |

> 把EVM理解成一种采用分布式系统的虚拟大电脑，那么在电脑中，读写需要调用内存，而计算在CPU内即可完成。后者需要消耗更多的Gas，合理的。

# 数据类型
Solidity中最基础的数据类型包括：
- 布尔类型（`bool`）：布尔类型表示真或假的值。
- 整数类型：整数类型分为有符号和无符号两种。有符号整数类型包括`int8`、`int16`、`int32`、`int64`等，而无符号整数类型包括`uint8`、`uint16`、`uint32`、`uint64`等。这些类型表示**不同位数**的整数。
- 固定点数类型：固定点数类型用于**处理小数**。例如，`fixed`和`ufixed`表示固定点数，后面可以跟着小数点的位数。
- 地址类型（`address`）：地址类型表示以太坊网络上的**账户地址**。
- 字节类型（`bytes`）：字节类型表示一组字节数据。例如，`bytes32`表示32个字节的数据。
- **动态**字节数组类型（`bytes`）：动态字节数组类型与字节类型类似，但其**长度可变**。
- 字符串类型（`string`）：字符串类型表示文本数据。
- 枚举类型（`enum`）：枚举类型用于定义一组**离散的可能取值**。
- 映射（`mapping`）
其中`uint`、`int`、`bytes`后面都可以跟上具体的数字，表示分配空间的大小【多少`bit`】
>通常，把分配空间显式地写出来是一个好习惯


# 关键字
## contract
- 它告诉编译器后面的代码是来定义智能合约的。（类似面向对象语言中的class关键字）
## function
- 和常见的编程语言类似，函数通过`function`关键字表示。

# 修饰符
## 可见度标识符
如果没有显式指定变量的**访问修饰符**，则**默认为`internal`**，而`internal`关键字表示，它只对本合约和继承合约可见。
### public
- `public` 函数可以在合约内部调用或者通过消息在合约外部调用
- 最高级别的可见度标识符，表示变量、函数或合约对内外部都可见。
- 公共状态变量可以被任何人读取，并且公共函数可以被**外部调用者**❓调用。
- 公共函数和状态变量的访问可以通过**合约地址**直接进行。
- 当你在`Solidity`中使用`public`关键字修饰一个状态变量时，`Solidity`编译器会自动生成一个类似`getter函数`的方法来允许**外部调用者**读取该变量的值。
	- 需要注意的是，`public`关键字只会生成一个`getter函数`用于读取状态变量，而不能直接修改状态变量的值。
	- 如果你希望**外部调用者**能够修改状态变量的值，你可以使用`setter函数`或将状态变量声明为可写入的。
### private
- `private` 函数仅在其被定义的合约内部可见，并且在该合约的派生合约中不可见
- 最低级别的可见度标识符，表示只有当前合约内的其他函数才能访问该变量或函数。
- 私有状态变量只能在当前合约中访问，私有函数只能被当前合约的其他函数调用。
- 私有状态变量和函数对外部调用者是不可见的。
### internal – 不会创建以太坊虚拟机调用
- internal 表示内部可见性，表示只有当前合约及其派生合约内的其他函数才能访问该变量或函数。
- 内部状态变量和函数可以在当前合约及其派生合约中访问，但对**外部调用者**不可见。
### external– 会创建以太坊虚拟机调用
- external 可以用于函数，表示该函数只能通过外部消息调用。
- 外部函数只能被其他合约调用，而不能在当前合约内部直接调用。
- 此外，外部函数不能访问合约的状态变量，只能通过参数和返回值进行数据交互。

## view和pure
	Solidity中有两个关键字，标识函数的调用不需要消耗gas。这两个关键字是view和pure。

| **修饰符**    | **访问权限**                              | **Gas 消耗**     | **典型场景**           |
| ---------- | ------------------------------------- | -------------- | ------------------ |
| **`view`** | 可读取状态变量（如 `mapping`、`uint`），但**不可修改** | 不消耗 Gas（若本地调用） | 返回合约状态（如查询余额、配置参数） |
| **`pure`** | **不可读取或修改**任何状态变量                     | 不消耗 Gas（若本地调用） | 纯计算逻辑（如数学运算、数据转换）  |
|            |                                       |                |                    |
```solidity
contract CheckExample {
    uint public data;

    function failPure() public pure {
        uint x = data; // 编译错误：pure 函数不能读取状态变量
    }

    function failView() public view {
        data = 10; // 编译错误：view 函数不能修改状态变量
    }
}
```
### view
- 只会读取这个合约的状态
- view函数不允许修改任何状态
```Solidity
function retrieve() public view returns(uint256) { 
	return favoriteNumber; 
}
```

- 调用view函数是免费的，除非在消耗gas的函数中调用它。
- 如果一个要改变区块链状态的函数调用了类似retrieve这种view或者pure函数才会消耗gas。
### pure
- pure函数也不允许修改状态
- pure也不允许读取区块链数据

# 作用域
	作用域决定了变量和函数的可见性和访问权限
## 全局作用域
在合约的整个范围内可见的变量和函数属于全局作用域。这些变量和函数可以被合约内的任何地方访问。
## 合约作用域
在合约内部声明的变量和函数具有合约作用域，它们只能在声明它们的合约内部访问。
## 函数作用域
在函数内部声明的变量具有函数作用域，只能在该函数内部访问。这些变量通常被称为局部变量。
## 事件作用域
在 Solidity 中，事件也有其特定的作用域。事件在声明它们的合约内部可见，可以被合约内的任何函数调用来触发。

# `constructor` 函数
只在首次部署合约时执行一次。 与许多基于类的编程语言中的 `constructor` 函数类似，这些函数常将状态变量初始化到指定的值。

# 函数调用
当函数调用与合约中指定的函数不匹配时，将执行[回退函数](https://docs.soliditylang.org/en/latest/contracts.html#fallback-function)

# 合约继承
	通过继承，子类可以复用父类的代码，同时还可以添加自己的新功能或重写父类的方法。
## 继承的语法
在 Solidity 中，使用 `is` 关键字来实现继承
```solidity
contract BeaconProxy is Proxy {
...
}
```
- `contract BeaconProxy`：定义了一个名为 `BeaconProxy` 的新合约。
- `is Proxy`：这是 Solidity 中合约继承的语法，意味着 `BeaconProxy` 合约继承自 `Proxy` 合约。
	- 继承的概念类似于**面向对象编程中的类继承**
		- `BeaconProxy` 合约可以复用 `Proxy` 合约中定义的状态变量、函数等，同时还可以添加自己的新功能或重写父合约的函数。
## 继承的特点
- **代码复用**：子类可以直接使用父类中定义的状态变量和函数，避免了代码的重复编写。
- **可扩展性**：子类可以添加自己的新功能，或者重写父类的方法以实现不同的行为。
- **层次结构**：可以形成多层次的继承关系，一个子类可以再被其他合约继承，形成复杂的代码结构。

# 2025-08-05

参与了web3安全钓鱼线上分享会，了解到有https://unphishable.io/这样一个钓鱼测试题网站。

# 2025-08-04

看书《以太坊技术详解与实战》，学习以太坊基础概念和技术。


# 2025.07.31


<!-- Content_END -->
