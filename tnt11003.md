---
timezone: UTC+8
---

# It

**GitHub ID:** tnt11003

**Telegram:** @cuiwu_It

## Self-introduction

互相学习

## Notes

<!-- Content_START -->
# 2025-08-20

ETH的数据结构

​	**Merkle Patricia tree**

特点：每次发布新区块，状态树中部分节点状态会改变。但改变并非在原地修改，而是新建一些分支，保留原本状态。仅有新发生改变的节点才需要修改，其他未修改节点直接指向前一个区块中的对应节点。（保存原本状态便于回滚）

​	所以：系统中全节点并非维护一棵MPT，而是每次发布新区块都要新建MPT。只不过大部分节点共享

​	最后在状态树中，**保存的仍是kv结构，key为地址，v为序列化后的值**进行存储

DApp

​	了解前端集成钱包插件，相关的函数

# 2025-08-17

## 比特币网络的工作原理

​		比特币工作于网络应用层，底层（网络层）是一个P2P Overlay network（P2P覆盖网络）。比特币系统中所有节点完全平等，不存在超级节点(super node)。

​		要加入网络，至少需要知道一个种子节点，通过种子节点告知自己它所知道的节点。节点之间的通信采用了**TCP**协议，便于穿透防火墙。当节点离开时，只需要自行退出即可，其他节点在一定时间后仍然没有收到该节点消息，便会将其删掉。

​		比特币网络设计原则：**简单、鲁棒（最坏情况下能达到最优状况，即健壮性）而非高效**。

每个节点维护一个邻居节点集合，消息传播在网络中采用洪泛法，某个节点在收到一条消息会将其发送给所有邻居节点并标记，下次再收到便不会再发送该消息。邻居节点选取随机，未考虑网络底层拓扑结构，也与现实世界物理地址无关。该网络具有极强鲁棒性，但牺牲了网络效率。

​		比特币系统中，每个节点要维护一个等待上链的交易集合。第一次听到交易，若是合法交易，则将其加入该交易集合并转发给邻居节点，以后再收到该交易就不再转发（避免网络上交易无线传输）。

> 区块大小越大，网络上传播时延越长；区块大小越小，则可以包含的交易数目越少。

​    比特币网络传播属于**Best effort（尽力而为）**，不能保证一定传输成功。以一个交易发布到网络上，未必所有节点都能收到，也未必所有节点收到交易顺序都一致。

# 2025-08-16

区块链应用学习


### BTC数据结构

#### Hash pointer（哈希指针）

- 指针

  ​	在程序运行过程中，需要用到数据。最简单的是直接获取数据，但当数据本身较大，要占用大空间时，不能直接使用。引入指针这一概念。当需要获取数据时，只需要按照指针所给的地址，节省内存。

  指针实际上存储的是逻辑地址而非物理地址。

  > 在比特币中，其最基本的数据结构便是一个个区块形成的区块链。

- 区块链与链表区别1：哈希指针代替普通指针

  ​	每个区块根据自己的区块内容生成自己的哈希值，此外，每个区块（除创世纪块）都保存有前一个区块的哈希值。本区块哈希生成依赖于本区块内容，而本区块内容中又包含有前一个区块的哈希值。从而保证了区块内容**不被篡改**。

  

  #### Merkle Tree(默克尔树)

1. Merkle Tree用哈希指针代替了普通指针

   ​    在区块块头中存储的是根节点的哈希值（对其再取一次哈希）。

   ​    数据结构优点：只需要记住Root Hash（根哈希值），便可以检测出对树中任何部位的修改。

2. Merkle Tree的实际用途

   ​    Merkle Tree可以用于提供Merkle Proof。关于Merkle proof，需要先了解比特币系统中节点。比特币中节点分为轻节点和全节点。全节点保存整个区块的所有内容，而轻节点仅仅保存区块的块头信息。

   > 为什么要分轻节点和全节点？
   > 硬件的局限。一个区块大小为1MB，对于移动便携设备来说，如果存储区块的所有内容，则所需空间过大，耗损大。所以轻节点只需要存储区块块头信息，全节点存储区块所有内容即可。

​          当需要向轻节点证明某条交易是否被写入区块链，需要用到Markle proof。将交易到根节点这一条路径称为Merkle proof，全节点将整个Merkle proof发送给轻节点，轻节点即可根据其算出根哈希值，和自己保存的对比，以此验证该交易是否被写入区块链。只要沿着该路径，所有哈希值都正确，说明内容没有被修改。



### 数字货币中经常出现的问题

- 双花攻击

  数字货币本身为带有签名的数据文件，可以进行复制。例子：对用户来说，可以将同一货币花费两次。

  > 修改：对货币添加唯一编号（不可篡改），每次支付向货币发行单位查询真伪。
  > 该方法每次交易都需要依赖于第三方机构来判断货币真伪且防止双花攻击。通常第三方机构具有较高的可信度；
  > 但很多场景下，并不存在这样一个可信赖的第三方机构（中心化高信任度机构）。以去中心化思想为核心的比特币系统依据需求而创造出来

# 2025-08-15

### 部署实践

部署 DApp，实践



使用Remix测试写Demo



昨日补充，节点间的数据一致性是怎么实现的。有什么问题（链下计算、批量处理）

PoW（工作量证明）

- 基于算力竞争记账权，谁第一个破解获得奖励

  - 无持币门槛
  - 攻击需控制全网算力超过50%

  

PoS（权益证明）

- 质押一定代币，获得记账权的概率增多

# 2025-08-14

### 2025.08.14

#### 1、DApp学习部署（部署到以太网=发起一笔交易？）

#### 2、补充

- p2p：

  - 1、**去除对单一节点的依赖。**节点间同时作为服务端和客户端

  - 2、在隐私度高和文件共享领域广泛应用。但监控率受限

    

    写智能合约注重点：

​				1、GAS优化

​				2、合约安全



#### 3、分布式

什么是分布式？解决了什么问题？还有什么问题？

- 将独立计算机规划为节点，多个节点间通过网络连接，协同完成工作，但是对外来说是一个整体。
- 解决问题
  - 单点节点故障，例如备份，节点挂掉换节点。容灾强
  - 性能瓶颈，分而治之的思想。（CDN服务？也算是一种吧）
  - 共享数据
- 问题
  - 优先感觉就是性能问题
  - 一致性
  - 信任度

##### 如何实现分布式的？怎么实践？

分布式集群



#### 4、共识机制

什么是共识机制？怎么实现的？解决了什么？问题？

1. 共识机制更类似于信任机制，使所有节点间完全可信，且对相同的数据有一致认知。
   - 去中心化信任
   - 数据一致性
2. 好了到这块就不懂了，神算法（囧）
3. 网络节点之间的信任问题；数据一致性问题（？咋解决的）。；去中心化，选举机制

# 2025-08-13

## 技术分享总结

### 1、重新认识以太坊

一个完整的经济系统？从何说起（数字经济系统）

1、技术基础设施

2、金融基础

​	分层经济系统？什么是

3、经济参与者和经济指标

参与者：开发者、用户、代币持有者和机构

指标：链上数据是实时监测

还有生态的发展，活跃用户多



什么是p2p？

一种**去中心化的网络架构**（底层网络范式？），特征：**节点平等 direct交互**，无需依赖中心化服务器

1、去中心化

2、自组织和容错



技术依赖的是什么？



与区块链有什么关系？如何应用的。



测试搭建：https://lxdao.notion.site/24bdceffe40b80148b07fa28483662cf

# 2025-08-10

制作一个NFT

学习[Solidity](https://solidity.readthedocs.io/)

核心语法：

变量作用域：

数据类型 

​	值类型： 1、布尔：bool 

​					2、整型：uint8/16/.../256

​					 3、地址：address（20字节） 

​	引用类型： 

​					1、数组：uint[]（动态数组）、uint[5]（固定长度） 

​					2、结构体：struct User { string name; }

​					 3、映射：mapping(address => uint) public balances; 



函数特性 

​	可见性：public（合约内外）、external（仅外部）、internal（仅合约/子类）、private 状态修饰符：view（只读）、pure（无状态交互） 



特殊函数：receive()（接收ETH）、fallback()（默认调用） 



控制结构 if/else, for/while, require(condition, "error")（条件检查）

高级特性：

1、合约交互

2、事件与日志（事件机制设怎么运行得，与web2的日志有什么区别么？）

# 2025-08-09

**Layer1 vs Layer2扩展方案**

- **Layer1优化**：分片技术（以太坊Sharding）、共识机制升级（如Solana的PoH+PoS）

- Layer2方案

  - Optimistic Rollups

    （Optimism、Arbitrum）：

    - 假设交易有效，欺诈证明窗口期（7-14天）内可挑战
    - 适合通用计算，兼容性高

  - ZK-Rollups

    （zkSync、StarkWare）：

    - 零知识证明验证交易有效性，实时确认
    - 适合高频交易（如dYdX去中心化衍生品）

  - **状态通道**（Lightning Network）：链下高频交易，通道内多次转账后上链结算



**1. 预言机实现原理**

- Chainlink喂价机制

  1、多个节点从API获取数据 → 提交到链上聚合合约 → 剔除异常值后取中位数

  2、节点需质押LINK代币防止作恶

  应用场景

  - DeFi：AAVE利率计算依赖Chainlink价格
  - 保险：航班延误险通过预言机验证现实数据
  - 

**2. 链上数据索引 - The Graph**
开发流程

1.定义数据源（智能合约事件）

 2.编写映射函数（AssemblyScript处理事件）

3.部署到The Graph节点


 #### 一、Solidity语言核心特性

 **1. 专为区块链设计的智能合约语言**

- **定位**：Solidity是**以太坊虚拟机（EVM）**的原生语言，专注于编写可部署在区块链上的智能合约。
   - **图灵完备性**：支持复杂逻辑（如循环、条件判断），但受限于Gas机制防止无限循环。
   - **状态管理**：合约变量永久存储在区块链上（状态变量），需通过交易触发修改。

.**2. 语法与特性**

 - 静态类型编译时检查类型安全 

   - **面向合约**：以`contract`关键字定义合约，类似于面向对象中的类，但更强调合约的**不可篡改性**和**透明执行**。

   - 事件（Event）

     通过event关键字定义事件，链下应用可通过日志监听合约状态变

   - **Gas优化**：需显式管理Gas消耗（如避免高成本操作`storage`），代码效率直接影响运行成本。



 与Java的区别？

**1. 执行环境与状态持久性**
.- Solidity
      - 代码运行在EVM上，合约状态（如代币余额）存储在区块链分布式账本中，**不可篡改**。
      - 每次状态修改需支付Gas费用（由交易发起者承担）。
    - Java
      - 运行在JVM上，状态默认存储在内存或传统数据库（如MySQL），**可修改**。
      - 无Gas机制，计算资源由服务器承担。

 **2. 并发与性能**

 - Solidity
      - 无原生多线程支持（区块链节点全局单线程执行合约）。
      - 性能受限于EVM和Gas限制（如复杂计算易导致Gas超限）。
    - Java
      - 支持多线程（`ExecutorService`）、异步编程（`CompletableFuture`）。
      - 性能优化工具丰富（如JIT编译器、GC算法）。

 **3. 开发范式差异**

 - Solidity
      - **事件驱动**：通过`emit`触发事件，链下应用监听事件更新状态。
      - **无传统I/O**：依赖预言机（Oracle）获取链外数据（如`Chainlink`）。
    - Java
      - 支持标准I/O（文件、网络）、数据库连接（JDBC）、GUI开发（JavaFX）。
      - 依赖第三方库生态（如Spring框架）。

 **4. 安全与漏洞模式**

- Solidity典型漏洞
      - 重入攻击（未检查调用者权限）、整数溢出（需`SafeMath`库）。
      - 修复方案：代码审计+遵循安全规范（[OpenZeppelin合约模板](https://www.openzeppelin.com/)）。
    - Java典型漏洞
      - 内存泄漏、SQL注入。
      - 修复方案：依赖IDE工具+安全框架。



JVM和EVM的区别？

# 2025-08-08

### 智能合约开发流程

#### Dapp架构

1、前端：页面+身份验证、钱包授权

2、智能合约：定义业务逻辑，部署在区块链上。（合约部署，无法修改）

3、数据检索器：起到中转地作用，通过输入地地址参数，去传统数据库中，获取全部地信息

4、数据存储：Dapp保证所有数据在多个节点均有备份



练习：使用Remix测试合约



#### 语法：

函数修饰符：对于合约来说

私有private

公开public：对外提供公共接口

外部external

继承internal



状态修饰符：

pure：不读取，不改状态函数

view：只读，不改状态

payable：接收以太币函数？

无修饰符：读取和修改状态



payable和无修饰符的有什么区别？



#### 状态机是什么？都有哪些种类？



#### Event机制



### Layer2

区块链扩容的关键解决方案

#### 是什么？解决了什么问题？

​	将链上运行转移至链下，只确定最终结果。省略运行时长，增加线上吞吐量，省gas费用。

  Layer2是构建在区块链主链（Layer1）之上的第二层协议，通过将部分交易和计算转移到链下处理，仅将**最终结果锚定到主链**，从而提升系统吞吐量并降低交易成本。

##### 	什么又是Layer1呢

什么作用？解决什么问题？

负责核心功能如：

1、共识机制（决定节点如何达成一致）；

2、数据存储（记录所有交易和智能合约状态）；

3、交易验证（通过密码学和经济模型抵御攻击）；

区块链网络的**底层协议层**



在智能合约执行过程时

# 2025-08-06

### 岗位景图

1、确定想要应聘的岗位：依旧技术方向，但想了解产品

2、确定学习方向：先学能够共通的技术


岗位：

后端岗：

1、python

2、数据库共用，这块可以着重

3、主要还是有项目经验，与web2基本相似



以太坊技术技术

1、账户模型EOA：用户私有，私钥控制；GAS费用自费

​		合约账户CA：EOA调用或者合约内部调用；GAS费用调用者



虚拟货币比不过法定货币，不受安全保护

web3由于限制，多数采用包的形式，入行仔细甄别

web3特殊性，项目可能设计灰色

# 2025-08-04

## 区块链的概念？

### 1、什么是区块链？

由区块和链条组成。

区块：存放交易记录等信息+前一个区块的区块摘要（哈希）

​	特性：区块大小有限；每个区块在一定时间内打包

链：一条链只能链接两个区块，只有一条链，串联起整个区块；如图：

![image-20250804205553103](../picture/Acui/image-20250804205553103.png)



区块链特性：

​	1、不可篡改：区块中存放了前一个区块的哈希，要修改就只能修改全部的块

​		分布式特性，在多个矿机（节点）上都存有完整的链条，修改超过半数，交易才被认可。

​	2、公开透明、匿名？（为什么）：

​	对于本次交易，产生随机的钱包地址，对于他人来说，这个钱包地址理应来说是未知的，实现匿名。又因为与这个钱包地址有关的交易会因为分布式的原因公开，能够被查询到，所以又是公开透明的。

​	前提是仅仅只针对这次交易（钱包地址）



**描述区块链**

一张网状生态链，由一条完整链存储在多个节点上，节点提供计算服务，实现钱包交易。



### 2、区块链的种类：

1、公链：公开链，供所有加入人访问，交易。缺点：人多，效率慢

2、联盟链：类似与公司

3、私链：个人工作室



### **3、区块链如何运行的呢？**

​	与正常交易步骤近乎一致

1、用户发起钱包交易

2、传播交易：找到交易双方

3、验证资质：矿工节点验证余额，签名是否合法

4、交易：将验证过的节点，打包成区块

5、记录：记录上链，更新全网节点状态（那这样会不会很慢？分布式？）

6、给节点提供奖励，使其能够继续支持



照理来说，链上记录所有的信息和历史，那么数据链是不是越来越大，且减不了，用hash分片存储么，存储唯一id，连接链为一个区块链？



![image-20250804214118936](../picture/Acui/image-20250804214118936.png)

智能合约：存储在区块链上的可执行代码，在符合条件下自动执行操作





## **什么是分布式**



**什么是btc？**

数字货币一种，限量，可自由交易。



## 什么是以太坊？

加密货币+支持智能合约（技术协议）（一经编写发布，不可修改）

借助分片和 Layer 2技术



### 1、以太坊核心机制：

三部分组成：账户系统、Gas模型、以太坊虚拟机（EVM）

账户系统分为：外部账户（EOA）、合约账户（CA）

你自己的私钥控制外部账户EOA，合约账户CA由内部的智能合约控制

每个账户包含四个阶段：

Nonce：计数器，防止重复交易

余额：

CodeHash：EOA为空哈希，CA存储合约字节码的哈希值（为什么这样设计）

StorageRoot：计算账户数据



2、Gas模型：提供交易的燃料费

对于EOA发起的交易，提供计算费用



3、以太坊虚拟机：代码执行的虚拟引擎

确保在整个网络中，处理代码的结果都一致。

和Java的JVM有什么区别：





### 2、什么是Layer 2





### 3、什么是**Proto-Danksharding**？





## 什么是web3？

与web2区别：价值归属权的重构



什么是web2：中心化管理所有的用户数据，你的数据不是你能管理的。

什么是web3：去中心化，你的数据归你所有。





## 行业赛道


# 2025.07.29


<!-- Content_END -->
