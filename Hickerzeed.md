---
timezone: UTC+8
---

# 胡星兆

**GitHub ID:** Hickerzeed

**Telegram:** @Huxingzhao

## Self-introduction

是个正常人类

## Notes

<!-- Content_START -->
# 2025-08-19

初始化交易池
初始化交易池调用的是 UniswapV3Factory 合约的 initialize，参数为当前价格 sqrtPriceX96，含义上面已经介绍过了。
代码如下：
/// @inheritdoc IUniswapV3PoolActions
/// @dev not locked because it initializes unlocked
function initialize(uint160 sqrtPriceX96) external override {
    require(slot0.sqrtPriceX96 == 0, 'AI');

    int24 tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);

    (uint16 cardinality, uint16 cardinalityNext) = observations.initialize(_blockTimestamp());

    slot0 = Slot0({
        sqrtPriceX96: sqrtPriceX96,
        tick: tick,
        observationIndex: 0,
        observationCardinality: cardinality,
        observationCardinalityNext: cardinalityNext,
        feeProtocol: 0,
        unlocked: true
    });

    emit Initialize(sqrtPriceX96, tick);
}

首先从 sqrtPriceX96 换算出 tick 的值。
int24 tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);

然后初始化预言机，cardinality 表示当前预言机的观测点数组容量， cardinalityNext 表示预言机扩容后的观测点数组容量，这里不详细解释。
(uint16 cardinality, uint16 cardinalityNext) = observations.initialize(_blockTimestamp());

最后初始化 slot0 变量，用于记录交易池的全局状态，这里主要就是记录价格和预言机的状态。
slot0 = Slot0({
    sqrtPriceX96: sqrtPriceX96,
    tick: tick,
    observationIndex: 0,
    observationCardinality: cardinality,
    observationCardinalityNext: cardinalityNext,
    feeProtocol: 0,
    unlocked: true
});

Slot0结构如下，源码中已经有了详细的注释。
struct Slot0 {
    // the current price
    uint160 sqrtPriceX96;
    // the current tick
    int24 tick;
    // the most-recently updated index of the observations array
    uint16 observationIndex;
    // the current maximum number of observations that are being stored
    uint16 observationCardinality;
    // the next maximum number of observations to store, triggered in observations.write
    uint16 observationCardinalityNext;
    // the current protocol fee as a percentage of the swap fee taken on withdrawal
    // represented as an integer denominator (1/x)%
    uint8 feeProtocol;
    // whether the pool is locked
    bool unlocked;
}

至此完成了交易池合约的初始化。

# 2025-08-18

部署交易池
在 Uniswap V3 中，通过合约 UniswapV3Pool 来定义一个交易池子，Uniswap 最核心的交易功能在最底层就是调用了该合约的 swap 方法。
而不同的交易对，以及不同的费率和价格区间（后面会具体讲到 tickSpacing）都会部署不同的 UniswapV3Pool 合约实例来负责交易。部署交易池则是针对某一对 token 以及指定费率的和价格区间来部署一个对应的交易池，当部署完成后再次出现同样条件下的交易池则不再需要重复部署了。
部署交易池调用的是 NonfungiblePositionManager 合约的 createAndInitializePoolIfNecessary，参数为：
- token0：token0 的地址，需要小于 token1 的地址且不为零地址；
- token1：token1 的地址；
- fee：以 1,000,000 为基底的手续费费率，Uniswap v3 前端界面支持四种手续费费率（0.01%，0.05%、0.30%、1.00%），对于一般的交易对推荐 0.30%，fee 取值即 3000；
- sqrtPriceX96：当前交易对价格的算术平方根左移 96 位的值，目的是为了方便合约中的计算。
代码为：
/// @inheritdoc IPoolInitializer
function createAndInitializePoolIfNecessary(
    address token0,
    address token1,
    uint24 fee,
    uint160 sqrtPriceX96
) external payable override returns (address pool) {
    require(token0 < token1);
    pool = IUniswapV3Factory(factory).getPool(token0, token1, fee);

    if (pool == address(0)) {
        pool = IUniswapV3Factory(factory).createPool(token0, token1, fee);
        IUniswapV3Pool(pool).initialize(sqrtPriceX96);
    } else {
        (uint160 sqrtPriceX96Existing, , , , , , ) = IUniswapV3Pool(pool).slot0();
        if (sqrtPriceX96Existing == 0) {
            IUniswapV3Pool(pool).initialize(sqrtPriceX96);
        }
    }
}

逻辑非常直观，首先将 token0，token1 和 fee 作为三元组取出交易池的地址 pool，如果取出的是零地址则创建交易池然后初始化，否则继续判断是否初始化过（当前价格），未初始化过则初始化。
我们分别看创建交易池的方法和初始化交易池的方法。

# 2025-08-17

区块链就像黑匣子一样是封闭的，无法与外部世界影响，智能合约本身也完全无法连接链下数据。对于现实世界中的例如：天气、比赛分数以及航班信息等都无法获取，这也是智能合约最大的痛点，极大地限制了智能合约开发者的创造力，那么有什么办法可以解决呢？
答：当然是有的，前置机则扮演此类角色，负责上传现实世界中的真实数据到智能合约。
主场机 分为 主场机 和 去 主场机 。
工作流程
![[粘贴图片 20250406175344.png]]
中心化前置机
负责上传现实世界的真实数据到智能合约的一个数据源，但是由于中心化的原因，中心化预示着机中不仅存在单点故障风险，而且还存在数据不安全风险，这又改变了相当程度的智能合约安全性的特性。
去中心化明天机
多个数据节点组成去中心机，每个节点都会收集数据，达成共识后输入到区块链的智能合约。而chainlink就是其中的一种。
- 技术上：避免了单点失败风险。
- 数据上：通过网络对多个数据源进行验证。
chainlink提供了数据馈送，VRF，自动化等功能，目前采用的意见机制是取中增量。
喂价
业务流程
- 数据主要：负责收集价格数据，将价格数据提供给下游机。
- 前置机节点：获得数据之后和前置机中的其他节点达成共识，随后将共识后的数据发送到chainlink
部署到区块链中的智能合约，最后用户可以通过部署到区块链中的智能合约获取到相应的价格数据。 !

# 2025-08-16

透明代理模式详解
一、代理模式简介
在以太坊的智能合约世界中，合约一旦部署便具有不可修改性。这种特性虽然为合约提供了强大的安全性，但在实际应用场景里，当我们需要修复合约中的bug或者其功能进行升级时，就会面临挑战。为了解决这个问题，代理模式应运而生。代理模式的核心思想以合约的逻辑与数据存储分离开来，从而实现合约的可升级性。
透明代理（Transparent Proxy）是代理模式中流行的一种，由OpenZeppelin提出并在行业内得到了广泛的应用。
二、透明代理的核心问题：函数选择器冲突
代理在模式实际应用中面临的核心挑战是函数冲突问题。当代理约定和逻辑约定中名称和参数都包含相同的函数时，就会产生冲突。例如，若逻辑约定和代理契约都包含upgradeTo(address)函数，那么调用时，系统将无法显式地执行哪个函数。
透明代理模式通过区分管理员和普通用户的调用，巧妙地解决了这个问题：
- 对管理员的调用：直接在代理合约中执行。
- 对普通用户的调用：转发到逻辑合约执行。
三、代码实现分析
3.1 代理合约实现
下面我们来详细分析TransparentProxy.sol关键实现部分：
contract TransparentProxy is Proxy {
    // EIP - 1967 存储插槽
    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;

    constructor(address _initImplementation, address _initAdmin) {
        // 设置逻辑合约地址
        assembly {
            sstore(_IMPLEMENTATION_SLOT, _initImplementation)
        }
        // 设置管理员地址
        assembly {
            sstore(_ADMIN_SLOT, _initAdmin)
        }
    }

    // 其他函数...
}
核心技术点
1.EIP - 1967 货架插槽
：透明采用固定的货架来货架实现地址和管理员地址。这些特殊的货架位置遵循EIP - 1967 标准，能够确保不会与逻辑紧密的货架布局产生冲突。
bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;
这些值是通过以下公式计算得出的：
// bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1)
// bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1)
2.内联存储访问存储：代理合约使用内联存储（assembly）直接操作存储，这样做是为了避免使用常规的Solidity存储变量，从而防止存储冲突。
assembly {
    sstore(_IMPLEMENTATION_SLOT, _initImplementation)
}
3.代理转发机制：_implementation()函数继承自Proxy合约，其主要作用是提供逻辑合约的地址。
function _implementation() internal view override returns (address) {
    address impl;
    assembly {
        impl := sload(_IMPLEMENTATION_SLOT)
    }
    return impl;
}
当用户调用转发约定中不存在的函数时，fallback函数（在基类Proxy中实现）调用转发到逻辑约定。
4.升级机制：代理合约提供了一个管理员管理员使用的升级函数：
function upgradeTo(address _newImplementation) external {
    require(msg.sender == admin(), "Only admin can upgrade");
    assembly {
        sstore(_IMPLEMENTATION_SLOT, _newImplementation)
    }
}
该函数只能由管理员调用，用于将代理合约指向新的逻辑合约实现。
3.2 逻辑合约设计
我们设计了两个版本的逻辑合约：
TransparentLogicV1.sol
contract TransparentLogicV1 is Initializable, OwnableUpgradeable {
    uint256 public value;

    function setValue(uint256 _value) public virtual {
        value = _value;
    }

    function getValue() public view virtual returns (uint256) {
        return value;
    }

    function initialize(address initialOwner) public initializer {
        __Ownable_init(initialOwner);
    }
}
TransparentLogicV2.sol
contract TransparentLogicV2 is TransparentLogicV1 {
    uint256 public newValue; // 新增状态变量

    function setValue(uint256 _newValue) public virtual override {
        newValue = _newValue;
    }

    function getValue() public view virtual override returns (uint256) {
        return value + newValue;
    }
}
核心技术点
1.可初始化合约：逻辑合约使用Initializable替代构造函数，这是因为在代理模式下，逻辑合约的构造函数不会被执行。
function initialize(address initialOwner) public initializer {
    __Ownable_init(initialOwner);
}
取消constructor构造函数，采用initialize初始化函数，可以在升级合约时自动设置初始化参数，而不是在合约创建时进行设置。
2.状态变量布局：在V2版本中，新增的状态变量newValue被添加到了原有变量之后，这样保持了存储结构的兼容性，是确保升级安全的关键。
四、透明代理使用流程
1.配置逻辑合约V1：首先配置第一个版本的逻辑合约。
2.配置透明代理合约：配置透明代理合约，将其指向V1的地址。
3.交互阶段：调用代理合约的地址，但使用V1的ABI进行交互。
4.升级准备：当需要进行升级时，部署V2逻辑合约。
5.合约升级：管理员调用合约的upgradeTo函数，将其指向V2地址。
6.继续交互：继续使用代理合约地址，但使用 V2 的 ABI 进行交互。
五、最佳实践与安全建议
1.状态设备：在升级合约时，不要修改、删除或重排现有状态设备，以确保存储设备的兼容性。
2.管理员权限分离：考虑使用多签钱包或DAO作为管理员，以增强权限管理的安全性。
3.初始化函数：确保初始化函数有适当的访问控制，防止未授权的初始化操作。
4.升级后验证：每次升级后，都要验证新功能是否正常工作，确保升级的稳定性。
5.存储或冲突规避：特定使用命名模式避免结构体存储冲突，保证持续的正常运行。
六、总结
透明代理模式是Solidity中实现合约可升级性的强大工具，它通过巧妙的设计成功解决了代理模式中的函数选择器冲突问题。深入了解其实现细节和工作原理，对于开发安全、可靠的可升级智能合约系统至关重要。
代理模式虽然为合约开发带来了灵活性，但同时也带来了复杂性和潜在风险。在实际应用中，开发者需要在可升级性和安全性之间进行权衡，严格遵循最佳实践，以保证系统的稳定性和安全性。

# 2025-08-15

UUPS 代理是基于 ERC-1967 标准设计的一种智能合约升级模式。与传统的透明代理模式（Transparent Proxy）不同，UUPS 将升级逻辑内置于实现合约，而不是代理合约本身。代理合约仅用于转发呼叫，所有逻辑由实现合约处理。
设计优势
这种设计带来了以下显着优势：
- 轻量化：代理合约中不包含复杂的升级逻辑。
- 灵活：开发者可以完全定制升级权限和流程。
- 标准化：基于ERC - 1967和ERC - 1822，兼容性好，相互集成。
UUPS代理的关键组成部分
UUPS代理由以下核心组件组成：
1.代理合同（Proxy Contract）
1.1职责
- 存储当前实现合约的地址。
- 使用delegatecall
将所有转发转发到实现合约。
1.2存储规范
遵循 ERC - 1967 标准，使用固定的存储存储IMPLEMENTATION_SLOT实现合约地址。
1.3轻量设计
代理合约不包含任何升级逻辑，仅负责转发呼叫。
2.实现合同（Implementation Contract）
2.1职责
- 包含具体的业务逻辑和升级逻辑。
- 提供对新实现兼容性的兼容性检查。
2.2接口规范
- 实现ERC - 1822标准中的proxiableUUID函数，用于验证实现兼容的兼容性。
- 通常基于 OpenZeppelin 的UUPSUpgradeable模块进行开发。
2.3升级管理
2.3.1权限控制
通过函数限制升级权限来实现合约_authorizeUpgrade。
2.3.2执行升级
升级操作由实现合约的upgradeTo或upgradeToAndCall函数执行。
2.3.3安全机制
- 内在上下文校验，保证只有代理合约可以调用升级逻辑。
- 验证新实现一致性的兼容性，避免意外升级。
UUPS代理的工作原理
UUPS代理的工作流程分为两部分：调用转发和合约升级。
转发
1.用户向代理发送请求。
2.代理合约通过delegatecall将请求转发到当前实现合约。
3.实现合约处理逻辑，并使用代理合约的存储。
合约升级
升级过程通过实现合约中的upgradeTo或upgradeToAndCall完成：
1.上下文校验：检查调用者是否为代理合约，防止直接调用实现合约中的升级逻辑。
2.权限验证：调用_authorizeUpgrade检查升级权限。
3.兼容性检查：验证新实现一致性proxiableUUID是否与ERC - 1967标准兼容。
4.存储更新：将代理合约中的实现地址更新为新合约地址。
5.初始化（任选）：在升级完成后，通过upgradeToAndCall执行初始化逻辑。
UUPS 与透明代理的对比
特性UUPS代理透明代理天然气成本彼此，仅在实现合约中包含升级逻辑。更高，需要维护额外的代理管理。复杂度大多数，需要实现权限和安全逻辑。较低，由Proxy Admin管理升级逻辑。安全性需要者手动保证权限控制和开发兼容性。代理管理提供额外的安全层。灵活高，可定制升级权限和逻辑。较低，受代理管理员限制。可扩展性更灵活，可支持多种升级策略。较低，适合单一升级模式的场景。
UUPS 代理的安全注意事项
权限控制
- 确保_authorizeUpgrade实现了严格的验证权限（如onlyOwner）。
- 避免任何用户触发升级逻辑。
仓储布局
新实现合约的存储架构必须完全兼容，否则会导致数据混乱。
兼容性检查
新实现合约必须实现proxiableUUID并返回正确的存储槽值。
初始化
升级后需要初始化新的状态变量时，必须通过upgradeToAndCall调用初始化函数。
总结
UUPS代理是一种轻量化且灵活的智能合约升级模式，适合需要高效管理升级逻辑的场景。它通过内置的权限验证、下游验证和兼容性检查，保证升级的安全性。同时，开发者可以根据需求定制升级逻辑，极大地提高了合约的可扩展性。
然而，在使用 UUPS 时，开发者需要特别注意权限控制和高效存储布局的兼容性，潜在的安全问题或存储冲突。通过正确的设计和实现，UUPS 代理能够智能合约提供安全、的升级能力。

# 2025-08-14

StateDB是区块链系统中的一个核心概念，主要用于存储和管理系统的状态数据。下面是对其的详细解释：
--------------------------------------------------------------------------------
✅ 什么是 StateDB？
StateDB状态数据库是区块链系统中用于存储每个账户（或合约）的最新状态的组件。它记录了包括账户余额、合约存储变量、nonce等所有与当前区块状态相关的数据。
--------------------------------------------------------------------------------
🧠 它解决了什么问题？
在区块链中，每个新区块的生成都伴随着系统状态的更新（比如账户余额变化、合约变量修改等），因此机制必须有一个来追踪和存储这些变化。这就是 StateDB 的作用：
- 保存所有账户并约定的当前状态
。
- 提供查询
和更新状态
的能力。
- 支持区块的回滚
与状态同等
，处理链的重组（reorg）或回退。
--------------------------------------------------------------------------------
🏗️ StateDB 通常包含哪些内容？
以以太坊为例，StateDB 中包含：
项目说明地址（地址）每个或用户约定的唯一标志余额（余额）账户中持有的ETH数量随机数账户已发送交易的数量，用于防止重放攻击存储（Storage）契约中的标志（键值对），通过 Merkle Patricia Tree 组织代码（代码）智能合约的字节码
这些数据通过一种称为Merkle Patricia Trie的数据结构存储，从而高效实现的查找、验证与同步。
--------------------------------------------------------------------------------
🧬 数据结构与存储形式
在如以太坊这样的系统中，StateDB并不是直接存在于普通的数据库中，而是被组织为：
- 账户状态树（State Trie）
：每个账户为一个节点
- 每个合约的存储又构成一个独立的 trie（合约存储 Trie）
整个状态树的根哈希（stateRoot）会被写入区块头中，确保状态不可篡改且可验证。
--------------------------------------------------------------------------------
💡举个例子
假设 Alice 向 Bob 转账 1 ETH，StateDB 会：
1.查找 Alice 和 Bob 的账户状态
2.减少 Alice 的余额，增加 Bob 的余额
3.更新这些状态在 Merkle Trie 中的位置
4.生成新的根存储，写入区块头
--------------------------------------------------------------------------------
📌小结
特性说明核心作用存储全网状态，包括账户、合约等数据结构多级 Merkle Patricia Trie与块的关系每个区块都有一个对应的状态根哈希（stateRoot）使用场景状态读取、状态更新、验证历史状态

# 2025-08-11

跨链桥笔记：打通区块链世界的“巴别塔”
想象一下：你生活在一个由许多岛屿（区块链）组成的巨大群岛世界。每个岛屿都繁荣昌盛，有自己的独特文化、规则和货币（代币）。你在“以太坊岛”赚了不少ETH金币，但听说“Solana岛”阳光明媚、交易又快又便宜，你想去那边投资或游玩。问题来了：你的ETH金币在Solana岛上没人认！

这就是跨链桥要解决的“大麻烦”：区块链之间的“孤岛效应”。

为什么需要“桥”？—— 打破孤岛
资产“出国”需求： 你想用比特币（BTC）参与以太坊上的DeFi挖矿？或者用你在Polygon上赚的MATIC去买Solana上的NFT？没有桥，门儿都没有。

追求“性价比”： 以太坊（主网）可能拥堵费贵，Arbitrum、Optimism这些“近海小岛”（Layer2）速度快费用低。你想把资产挪过去用？得靠桥。

扩展生态活力： 新链要发展，需要吸引其他链的用户和资金。桥就是重要的“招商引资”通道。

信息互通： 不仅仅是钱，有时数据、指令也需要在不同链间传递。

桥是怎么工作的？—— 核心原理：锁定 & 铸造 / 销毁 & 释放
可以把跨链桥想象成一个高度自动化的跨国银行+邮局系统：

你想“汇款”（跨链转移）：

出发岛（源链）： 你把你的代币（比如10个ETH）“存入”桥在这个岛上的保险柜（锁定合约）。保险柜牢牢锁住你的真ETH。

信息传递： 桥的“邮差”（预言机或验证者网络）确认：“喂！目标岛注意，有人锁了10个真ETH在我这，请求在你们那边发等值的‘旅行支票’！”

到达岛（目标链）： 桥在目标链上的“分行”收到确认信息后，立刻凭空印出（铸造） 10个代表ETH的“旅行支票”——这叫封装资产（如 wETH, bridgeETH）。这些支票的价值锚定你锁定的真ETH。

你收到了： 这10个“旅行支票”发送到你在目标链上的钱包。现在，你可以在目标链上自由使用它们了！它们不是“真”ETH，但价值等同于你锁定的ETH，并且可以被桥回收换回真ETH。

你想“回家”（跨链转回）：

当前岛（目标链）： 你把那10个“旅行支票”（封装资产）烧掉（销毁），发给桥看。

信息传递： “邮差”确认：“源链注意，10张支票已销毁，请求解锁真ETH！”

出发岛（源链）： 桥收到确认，打开保险柜（锁定合约），把你的10个真ETH释放回你在源链的钱包。

简单记：锁A链真币 → 在B链造“影子币” || 烧B链“影子币” → 在A链放真币。

桥有哪些类型？—— 按“谁管保险柜”分
托管桥（中心化桥 - 像“银行主导”）：

有个中心化的公司或组织管理那个“保险柜”（锁定的资产）。你需要信任这家公司不会卷款跑路或乱来。

优点： 通常速度快，用户体验可能简单。

缺点： 最大的风险就是信任风险！如果这家公司出问题（被黑、作恶），你的资产可能就没了。例子：很多早期交易所的桥。

感觉： 像把钱存进某家跨国银行，你得祈祷它别倒闭。

非托管桥（去中心化桥 - 像“社区共管”）：

那个“保险柜”是一个智能合约（代码），锁币规则公开透明，自动执行。

资产的安全由多方验证者（可能是节点、质押者、其他链） 共同保证。作恶需要很高的成本和勾结难度。

优点： 安全性更高，更符合区块链精神。通常需要抵押品来激励验证者诚实工作。

缺点： 可能比托管桥慢一点，有时更复杂，验证者本身也可能有漏洞。

感觉： 像把钱锁进一个由多方公证人共同监督的透明、自动化金库，想偷钱得收买大部分公证人，很难。

例子： Polygon Bridge (PoS桥), Arbitrum Bridge, Optimism Bridge, 一些基于多方安全计算或轻客户端的桥。

重要特点与风险提醒
封装资产： 你在目标链收到的通常不是“原生”代币，而是桥发行的、代表该资产的“包装”代币（如 wBTC, wETH）。记住它背后有真资产支撑（理论上）。

安全是命门！ 跨链桥是黑客眼中的“超级金库”，历史上被盗金额巨大（Ronin, Wormhole, Poly Network等事件）。风险点：

智能合约漏洞（代码有BUG）。

验证者被攻击或勾结（对非托管桥）。

管理员密钥泄露（对托管桥或某些混合桥）。

信任最小化是目标： 理想中的完美桥是几乎不需要信任任何个人或单一实体的（依靠数学和密码学），但这很难实现，是目前研发的重点（如使用ZK技术）。

费用： 跨链通常要交两笔手续费：源链的Gas费 + 目标链的Gas费 + 可能还有桥服务费。

速度： 取决于桥的设计，从几分钟到几小时不等。需要等待区块确认和验证过程。

总结一下
跨链桥是什么？ 区块链世界的“摆渡船”或“跨国银行系统”，让不同链上的资产和数据能互通有无。

核心任务？ 解决区块链“孤岛问题”，实现互操作性。

怎么干？ 锁定/销毁 + 铸造/释放 这套经典机制。

关键区别？ 谁控制资产（保险柜）：是中心化机构（托管）还是去中心化的代码和验证者（非托管/少托管）？

最大风险？ 安全！安全！安全！ 桥是黑客的重灾区，选择需谨慎。

# 2025-08-08

为什么要学习DEX
1.构建链上金融体系
DEX作为Web3金融体系的重要组成部分，与其他DeFi协议相互协作，共同构建了一个完整的链上金融生态系统。它可以与借贷协议、保险协议、衍生品协议等进行集成，实现资产跨链跳转、协议间激励博弈等功能，为用户提供更加丰富和多元化的金融服务。
2.推动行业创新与竞争
DEX的发展促使整个Web3行业不断创新和竞争。为了吸引用户和流动性，各个DEX不断进行技术创新和功能优化，降低交易成本，提高交易效率和安全性。同时，DEX之间的竞争也推动了行业的发展，使得整个Web3金融市场更加健康和活跃。
什么是DEX
在加密世界中，Uniswap 和 Blur 是广为人知的两个去中心化交易所典型代表。通常情况下，Uniswap 主要进行代币交易，而 Blur 聚焦于 NFT 交易。不过，规则并非绝对，如今 Uniswap 也具备了交易 NFT 的功能。
- 如何定义去中心化交易所
那么，怎样判断一个交易所是去中心化交易所呢？其实，最关键的一点在于其交易是否通过智能合约处理，而非借助中心化的服务器。若交易由智能合约来处理，那么这个交易所就属于去中心化交易所。
以 Uniswap 为例，当用户进行代币交易时，网站会提示用户连接钱包，经用户使用钱包签名交易后，最终由智能合约完成整个交易过程。在这个流程里，Uniswap 不存在自己的服务器来处理交易，完全依靠智能合约运作。想象一下，即便 Uniswap 的网站服务器出现故障，用户依然能够通过调用智能合约来完成交易。
与去中心化交易所相对的，是像 币安、OKX 这类中心化交易所。在使用这类交易所时，用户需要完成邮箱注册、实名认证、绑定手机、设置密码等一系列操作，随后借助币安的服务器完成交易。由于这种交易所的服务器是中心化的，一旦币安的服务器出现问题，用户便无法正常交易。
- 去中心化交易所的必要性
当下，中心化交易所貌似功能更强大，交易速度和效率更高。那么，为何还需要去中心化交易所呢？答案显然易见，除了能避免因服务器故障影响交易外，去中心化交易所还有诸多显著优势。
- 安全性保障
很多人首先会想到的就是安全性。在去中心化交易所中，资产由用户自行掌控，相对而言更加安全。这的确是一项重要优势，但并非唯一优势。就像 2022 年 11 月，全球第二大加密货币交易所 FTX 破产，这一事件震惊了整个行业。美国证券交易委员会（SEC）经过调查发现，自FTX创立起，其创始人就开始挪用客户资金。这种中心化控制下的安全问题，是去中心化交易所极力避免的。
- 利率与手续费自主性
除了安全问题，中心化交易所还存在利率和手续费控制方面的弊端。在大型的银行和金融机构，也会对金融体系实现一定程度的掌控。而 DeFi（去中心化金融）正是为了打破这种中心化控制而兴起，去中心化交易所正是 DeFi 中的关键组成部分。
- 高效与透明性
去中心化交易所具备更高的效率和透明度，它能够 24 小时不间断地运作，且交易公开透明。同时，它更容易与其他 DeFi 项目进行整合，例如与借贷协议整合，从而实现更多样化的金融服务。这些服务是通过开放且透明的智能合约来实现的，这不仅降低了搭建金融服务的成本，还大大提高了效率。
举个例子，假如某个项目想要发行自己的资产供用户交易。在传统的中心化交易所，这可能需要与交易所签订繁琐的合同，并让研发人员与系统进行对接，整个流程复杂且不可靠。然而在去中心化交易所中，只需要简单两步即可。第一步，将资产通过智能合约发布到链上；第二步，把资产加入去中心化交易所的流动性池，这样用户就能进行交易了。
- 塑造金融新格局
随着 DeFi 的不断发展，金融服务将变得愈发便捷，区块链技术也必将重塑金融服务的格局。作为整个去中心化金融体系下的重要基础设施，去中心化交易所的重要性不言而喻。
- 实现去中心化交易所的关键考量
要实现一个去中心化交易所，除了用户操作页面外，智能合约是重中之重。智能合约承担着处理用户交易请求、保障交易安全与透明的重任。对于负责交易处理的智能合约而言，最关键的就是如何在合适的时间以合适的价格，确保各种资产安全完成交易。
像 Blur 这类专注于 NFT 交易的交易所，交易逻辑相对简单。卖方可以指定一个价格，授权合约进行出售，买方随后授权合约购买；或者买家出价，卖家出售，整个交易过程由智能合约保障，无需三方担保，由智能合约管理资金和资产，这就是订单薄交易所的模式。
然而，这种模式对于 FT（同质化代币）交易来说就有些力不从心了。因为 FT 交易量大，对流动性的要求极高，需要更高效的交易模式。通过订单薄进行交易，无论是存储还是撮合等操作都需要执行合约，这会消耗大量 Gas（即区块链上执行合约所需的手续费）。
所以，针对去中心化代币交易所，需要更高效的交易模式，也就是 AMM（自动化做市商）。从技术层面讲，AMM 就是智能合约要实现的交易逻辑，它负责处理用户交易请求、管理资金池、计算价格，并确保有足够的流动性来支撑交易。
简单来讲，可以通过引入流动性提供者（Liquidity Provider）来实现。这些 LP 会将一对资产存入资金池，并给出初始定价。交易者无需像 NFT 交易那样等待买家，可直接在流动性池中随时买卖，而资产价格会随着持续的交易行为而变动。LP 在这个过程中能够获得相应激励。
Uniswap 基本介绍
Uniswap 是以太坊上最大的去中心化交易所（DEX），我们在上一讲中提到了，Uniswap 这样的去中心化交易所采用的不是订单薄交易的方式，而是由 LP 提供流动性来交易，这个流动性池子中的代币如何定价则成为了去中心化交易所的关键。Uniswap 在其流动性池上构建了一种特定的自动做市商（AMM）机制。称为恒定乘积做市商（Constant Product Market Makers，CPMM）。顾名思义，其核心是一个非常简单的乘积公式： $$ x∗y=k $$ 流动性池是一个持有两种不同 token 的合约， x 和 y 分别代表 token0 的数目和 token1 的数目， k 是它们的乘积，当 swap 发生时，token0 和 token1 的数量都会发生变化，但二者乘积保持不变，仍然为 k 。
另外，我们一般说的 token0 的价格是指在流动性池中相对于 token1 的价格，价格与数量互为倒数，因此公式为： $$ P=y/x $$ 就比如说我作为 LP 在池子中放了 1 个 ETH(token0) 和 3000 个 USDT(token1)，那么 k 就是 1*3000=3000，ETH 价格就是 3000/1 = 3000U。那你作为交易方就可以把大概 30 USDT 放进去，拿出来 0.01 个 ETH。然后池子里面就变成了 3030 个 USDT 和 0.99 个 ETH，价格变 3030/0.99≈3030U。ETH 涨价了，这样是不是就解决了定价的问题，有人要换 ETH，ETH 变得稀缺，所以涨价了，下次要换 ETH 就需要更多的 USDT，只要保证池子中的 ETH * USDT 等于一个常量，这样自然就会此消彼长，当 ETH 变少时，你要通过 USDT 换取 ETH 时候就需要消耗更多 USDT，反之亦然。
当然上面的例子没有考虑滑点、手续费、取整等细节，实际合约实现时也有很多细节需要考虑。这里只是为了让大家理解基础逻辑，具体的细节会在后面展开。
Uniswap 到目前已经迭代了好几个版本，下面是各个版本的发展历程：
2018 年 11 月 Uniswap V1 发布，创新性地采用了上述 CPMM，支持 ERC-20 和 ETH 的兑换，为后续版本的 Uniswap 奠定了基础，并成为其他 AMM 协议的启示；
2020 年 5 月 Uniswap V2 发布， 在 V1 的基础上引入了 ERC-20 之间的兑换，以及时间加权平均价格（TWAP）预言机，增加交易对的灵活性，巩固了 Uniswap 在 DEX 的领先地位；
2021 年 5 月 Uniswap V3 发布，引入了集中流动性（Concentrated Liquidity），允许 LP 在交易对中定义特定的价格范围，以实现更精确的价格控制，提升了 LP 的资产利用率；
2023 年 6 月 Uniswap V4 公开了白皮书的草稿版本，引入了 Hook、Singleton、Flash Accounting 和原生 ETH 等多个优化，其中 Hook 是最重要的创新机制，给开发者提供了高度自定义性。
2025年1月Uniswap V4 发布，V4 版本在算法上并没有改变，依然还是采用集中流动性，但通过 Hooks 实现了可定制的池，单例合约和闪电记账大幅度降低了 gas 成本，对原生 ETH 的支持也同样减少了 gas，还有对动态费用的支持、ERC1155 的支持等，都大大提高了 Uniswap 的灵活性、可扩展性。

# 2025-08-07

🌐 一、IPFS是什么？
想象一下：你上传一张照片，系统不把它存进某个机房，而是切成无数小碎片，打上唯一“指纹”（哈希值），再分散存到全球无数台电脑里。你想取回照片时，系统自动从离你最近的几台电脑收集碎片、拼成原图——这就是IPFS（InterPlanetary File System） 的核心逻辑。
- 目标：取代传统HTTP协议，让文件访问更快、更安全、永久保存（不再怕404！）15。
- 本质：一个点对点（P2P）的分布式文件系统，文件通过内容本身寻址，而非服务器位置17。
--------------------------------------------------------------------------------
🧩 二、核心工作原理：像拼图一样存储文件
1. 上传文件时（切碎→打标签→分发）
- 切块：文件被切成256KB的小块（想象成乐高零件）58。
- 计算哈希：每个块生成唯一加密“指纹”（CID，内容标识符），改动1字节指纹就全变15。
- 分发存储：碎片分散存到全球节点（比如你的文件可能同时存于东京、柏林、纽约的电脑）1。
2. 访问文件时（就近收集→快速拼合）
- 输入CID（如ipfs://QmXyz…），网络自动寻找离你最近、持有该碎片的节点，并行传输拼合文件14。
- 效果：
- ⚡ 速度提升：从邻居节点取数据，比跨洋访问服务器快得多49。
- 🔒 防篡改：哈希值匹配才接受文件，数据100%可信1。
--------------------------------------------------------------------------------
🔄 三、为什么比HTTP更强大？
传统HTTP像“打电话给中心客服”，IPFS则是“问身边人有没有你要的东西”：
对比项HTTP（传统）IPFS（分布式）寻址方式位置寻址（https://服务器地址/文件）内容寻址（ipfs://文件哈希值）抗故障能力服务器宕机＝文件消失（单点故障❌）全球节点备份，任意节点离线不影响访问✅抗审查政府/公司可删除或屏蔽内容文件分散存储，极难全网删除16带宽成本热门内容易拥堵（如抢演唱会票）就近分发，节省60%以上带宽5
💡 生动比喻：
- HTTP像图书馆——书在固定书架，借书得排队；
- IPFS像朋友间传阅——书被复印多份，谁有就找谁拿，更快更稳9。
--------------------------------------------------------------------------------
🚀 四、杀手级应用场景
IPFS特别适合这些领域：
1.NFT存储：
- 图像/音频存IPFS（CID上链），永不消失（避免“NFT变空白图片”惨剧）16。
2.抗审查网站：
- 加泰罗尼亚独立公投网站被屏蔽后，通过IPFS镜像重生7。
3.去中心化视频平台：
- 如DTube用IPFS存视频，省90%带宽成本，用户免广告69。
4.永久数据存证：
- 合同/病历存IPFS，链上仅存CID，司法可追溯14。
--------------------------------------------------------------------------------
⚙️ 五、关键生态组件：不只是存储
- Filecoin：IPFS的“激励层”，用户付代币存储文件，矿工赚代币提供硬盘空间16。
- IPFS Gateway：桥梁！让传统浏览器（如Chrome）也能访问ipfs://链接17。
- IPNS：给CID绑定“动态域名”，内容更新后链接不变（类似DNS）38。
--------------------------------------------------------------------------------
❗ 六、当前挑战与局限
- 冷门文件可能丢失：若无人“保种”（Pin），文件碎片会被节点清理5。
- → 解决方案：付费使用Filecoin或Pinata等持久化服务6。
- 随机读写性能不足：适合存大文件，不适合高频修改的数据库28。
--------------------------------------------------------------------------------
💎 总结一句话笔记
IPFS是Web3的存储基石，用内容寻址（CID） 替代位置寻址（URL），文件被切片分散存储，通过就近节点并行获取，实现更快、更抗审查、永久可用的分布式网络

# 2025-08-06

🎭 公链冤家录：以太坊 vs EOS 的十年恩怨
维度以太坊EOS诞生初心打造“世界计算机”，运行任意去中心化应用（2013白皮书）成为“以太坊杀手”，主打百万TPS高性能融资神话2014年众筹募资1800万美元（均价$0.3）史上最大ICO：42亿美元（2017-2018）巅峰时刻2021年DeFi锁仓$2000亿 + NFT破圈（BAYC 6900万美元成交）2018年主网上线市值冲至$22（现$0.58，蒸发98%）终局命运2024年ETF获批，机构持仓89.8亿美元2025年更名Vaulta，放弃EOS代币符号
--------------------------------------------------------------------------------
⚔️ 五大关键战役：理想主义 vs 现实溃败
1.性能之争：TPS神话的破灭
- EOS：曾宣称百万级TPS，但DPoS机制下21个超级节点暴露致命弱点：黑客可远程执行任意代码（360曝“史诗级漏洞”），普通用户因CPU租赁机制被拒之门外（日活仅3.2万 vs 以太坊160万）。
- 以太坊：早期仅15 TPS，但通过Rollup（如Arbitrum）和坎昆升级（EIP-4844）将Gas费降至 cents 级，实现“主网安全+L2速度”的模块化扩展。
2.生态战争：开发者用脚投票
- EOS：40亿美元融资仅12%投入生态建设，过度依赖空投炒作（如EIDOS），开发者转向Solana（年投5000万美元激励）。
- 以太坊：DeFi Summer（2020）催生Uniswap、Aave等协议，可组合性创新形成“货币乐高”，Gas消耗中金融应用占比超70%。
3.治理内斗：去中心化的悖论
- EOS：21个超级节点垄断资源，鲸交所等项目因分配不公出走，形成“节点寡头→生态萎缩”死亡螺旋。
- 以太坊：DAO事件硬分叉（2016）虽分裂出ETC，但确立社区治理范式；PoS转型后109万验证者分散权力。
4.监管博弈：合规化生死线
- EOS：团队募资协议声明“不承担任何运营责任”，资金去向不明遭SEC质疑。
- 以太坊：主动拥抱监管，2024年现货ETF获批成合规化标杆，机构持仓占比流通量1.92%。
5.信仰崩塌：社区共识的消亡
- EOS：散户持仓从18个月骤降至11天，“三浪看500”口号变笑话，持有者成“最坚定空头”。
- 以太坊：十周年NFT火炬传递活动，凝聚开发者信仰；V神称“下十年需思考实质影响”。
--------------------------------------------------------------------------------
💎 区块链达尔文法则：血泪启示录
- 技术≠胜利：EOS的TPS神话败给开发者体验，Solana以低Gas+Move语言逆袭。
- 共识需喂养：DOGE、SHIB的MEME生命力警示：纯技术叙事难持久。
- 合规定生死：XRP抗住SEC诉讼，EOS溃于治理缺陷。
- 基因即命运：BM三度弃项目而去，EOS结局早已注定。
📌 金句摘录：
“区块链没有永远的神话，只有不断进化的生存者。凝视Vaulta白皮书时，EOS燃烧的青春终成编年史注脚。” ——匿名核心开发者
双链竞争为镜，揭示区块链世界“理想向左，现实向右”的残酷法则——技术初心需配持续进化，方能在加密丛林中幸存 🌍⚡。

# 2025-08-05

今日主要学习如何防护钓鱼攻击
确认自身的目标，锁定目标岗位并进行第一步的实践
熟悉了一下岗位的职责

# 2025-08-04

备课，带领小伙伴们初步进行链上交互，了解web3知识


# 2025.07.29


<!-- Content_END -->
