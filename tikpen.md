---
timezone: UTC+8
---

# Lucas

**GitHub ID:** tikpen

**Telegram:** @fearbekilled

## Self-introduction

web2前端开发，对web3感兴趣，想加入web3.

## Notes

<!-- Content_START -->
# 2025-08-14

#### 1.搭建配置telegram社群

​	添加话题并加入Rose机器人

#### 2.完成专业文章排版

​	参考https://blog.ethereum.org/ 中的文章排版，完成一篇OKB暴涨的文章

# 2025-08-13

# Gas优化

#### 1.减少存储操作（Storage Write）

- 第一次读取存储需要 2100gas（后续100gas），内存读取仅 3gas。多次访问同一存储数据，应缓存到内存以减少 SLOAD（Storage Load）次数

- 每次写入 storage 的成本高达 20000gas；优先使用memory
- 示例

// ❌ 非优化写法
#
mapping(address => uint256) public balances;
#
function deposit() public payable {
#
    balances[msg.sender] += msg.value;
#
}

// ✅ 优化写法（一次读，一次写）
#
function deposit() public payable {
#
    uint256 current = balances[msg.sender];
#
    balances[msg.sender] = current + msg.value;
#
}

#### 2.使用位压缩（Bit Packing）

多个占用空间较小的变量**打包到同一个 256 位的存储槽（storage slot）里**，从而减少 SSTORE/SLOAD 次数，达到节省 gas 的目的。

##### 1.storage是按256位分配的

- EVM 中，每个 **storage slot** = **256 bits = 32 bytes**
- 无论你存一个 bool 还是一个 uint256，单独占用一个 slot 的 SSTORE 都要花费相同的成本（写入一次 storage = 20,000 gas）。
- 如果我们能把多个小变量（例如 bool, uint8, uint16 等）压缩到同一个 slot，就能**用一次存储写多个值**。

##### 2.示例

**未优化版本**

contract NoPacking {
    bool public a;       // 占 1 slot
    uint8 public b;      // 占 1 slot
    uint16 public c;     // 占 1 slot
}

虽然 a 只需要 1 bit，b 只需要 8 bit，c 只需要 16 bit，但它们各自单独占一个 256-bit 的 slot → 浪费 storage。

**优化版本**

contract BitPacking {
    uint8 public b;      // 8 bits
    uint16 public c;     // 16 bits
    bool public a;       // 1 bit（会当成 uint8 处理）
    // 这三个变量会被编译器打包到同一个 256-bit slot 里
}

编译器会按照声明顺序，把能放进一个 slot 的小变量打包到一起。

结果：

- 未优化版本：3 个变量 = **3 次 SLOAD / SSTORE**
- 位压缩版本：3 个变量共享 1 个 slot = **1 次 SLOAD / SSTORE**



##### 3.手动位压缩

有时变量不能自然打包（比如数组、mapping 或需要控制顺序），可以手动用位运算存取

contract ManualBitPacking {

  uint256 private data; // 256-bit 存储槽

  function setValues(uint8 a, uint8 b, uint16 c) external {

​    data =

​      uint256(a) |       // a 占最低 8 bit

​      (uint256(b) << 8) |   // b 占第 8-15 位

​      (uint256(c) << 16);   // c 占第 16-31 位

  }

  function getValues() external view returns (uint8 a, uint8 b, uint16 c) {

​    a = uint8(data & 0xFF);      // 取最低 8 bit

​    b = uint8((data >> 8) & 0xFF);   // 取第 8-15 位

​    c = uint16((data >> 16) & 0xFFFF); // 取第 16-31 位

  }

}	

##### 4.节省效果

- SSTORE 一次：20,000 gas
- 如果 3 个变量各占一个 slot → 3 × 20,000 = **60,000 gas**
- 如果打包到一个 slot → 20,000 gas（节省 **40,000+ gas**）

在频繁更新状态变量的合约里，尤其是链游、NFT、大数组场景，节省效果非常可观。


------

------


**以下是昨日笔记忘记提交**
# Dapp架构和开发流程

去中心化应用（Dapp）是与传统集中式应用不同的全新应用模式，通常运行在区块链或分布式网络上。由多个参与者共同维护。开发 Dapp 需要掌握去中心化技术栈、智能合约编程以及前端与区块链的交互方式。

### 1.Dapp架构



#### 1.前端（User Interface）

- ###### 前端是Dapp与用户交互的界面

- ###### 前端需要集成区块链钱包来进行身份验证和签署交易

#### 2.智能合约（Smart Contracts）

- ###### 智能合约是Dapp的核心，定义应用的业务逻辑，并部署在区块链上。智能合约通过执行自动化的规则来确保交易和操作的透明性与不可篡改性。

#### 3.数据检索器（Indexer）

- ###### 智能合约通常以 Event 形式释放日志事件，比如释放代表 NFT 转移的 Transfer 事件，数据检索器会检索这些数据并将其写入到 PostgreSQL 等传统数据库中

- ###### Dapp 在前端进行数据展示时需要检索器内的数据

#### 	  4.区块链和去中心化存储（Blockchain & Decentralized Storage）

- ###### 区块链用于存储智能合约的状态数据及交易记录。去中心化存储IPFS，用于存储大规模的非结构化数据（如图片、文档等），确保数据不易丢失和篡改。

### 2.Dapp开发流程

#### 1.需求分析与规划

- **确定功能需求**：需要定义用户可以进行的操作，比如转账、查询余额、创建投票等。
- **选择区块链平台**：决定在哪个平台上构建 Dapp（如以太坊、Solana、Polygon 等），这通常取决于目标用户群、交易成本、可扩展性等因素。
- **设计用户体验（UX）**：定义 Dapp 的界面设计和交互流程，确保用户能够轻松使用应用并与区块链交互。

#### 2.智能合约开发

- **编写智能合约**：使用 Solidity 或其他智能合约语言编写合约，确保合约的功能满足需求分析中定义的要求。
- **编写测试用例**：为智能合约编写单元测试，确保合约逻辑正确、无漏洞。
- **审计和优化**：对合约进行安全审计，确保合约的安全性，避免常见漏洞（如重入攻击、整数溢出等）。

#### 3.检索器开发

- **确定功能需要的数据内容**: 前端使用的数据大部份都直接来自检索器，所以开发者需要确定前端工程师所需要的数据

- **编写检索器程序**: 目前主流的检索器框架，如 ponder 和 subgraph 都是用了 TypeScript 语言作为检索器的程序编写语言，开发者主要编写事件数据清理以及事件数据写入数据库的代码

- **部署和运维**: 编写程序完成后，一般使用 Docker 部署到云服务器中，当然目前很多检索器框架也提供 SaaS 服务，同时检索器作为一个常规的数据库应用需要运维

#### 4.前端开发

- **选择前端框架**：使用前端框架来构建 UI。前端将通过 JavaScript 与智能合约进行交互。

- **连接钱包**：通过集成 **MetaMask** 等 Web3 钱包，用户可以连接到 Dapp，并授权其与智能合约交互。
- **显示区块链数据**：前端需要从区块链和检索器内获取数据（如账户余额、交易记录），并通过用户界面展示。
- **处理交易签名与确认**：当用户发起交易时，前端需要与钱包进行交互，获取用户的签名并将交易发送到区块链

#### 5.与区块链交互

- **读取数据**：前端通过智能合约的公共函数读取区块链上的状态数据（如余额、合约信息）。
- **发送交易**：当用户发起交易时，前端需要通过钱包签署交易并发送到区块链，执行合约中的某个功能（如转账）。

#### 6.部署与上线

- **部署智能合约**：推荐使用 **Hardhat** 或 **Foundry**（现代化开发工具）将智能合约部署到测试网（如 **Sepolia**、**Holesky**）或主网。

- **前端部署**：将前端应用部署到去中心化平台（如 **IPFS**）或传统的 Web 服务（Vercel）。
- **发布和维护**：将 Dapp 上线，进行用户反馈收集，定期更新合约和前端，修复潜在问题。

# Dapp架构和开发流程

去中心化应用（Dapp）是与传统集中式应用不同的全新应用模式，通常运行在区块链或分布式网络上。由多个参与者共同维护。开发 Dapp 需要掌握去中心化技术栈、智能合约编程以及前端与区块链的交互方式。

### 1.Dapp架构

#### 1.前端（User Interface）

- ###### 前端是Dapp与用户交互的界面

- ###### 前端需要集成区块链钱包来进行身份验证和签署交易

#### 2.智能合约（Smart Contracts）

- ###### 智能合约是Dapp的核心，定义应用的业务逻辑，并部署在区块链上。智能合约通过执行自动化的规则来确保交易和操作的透明性与不可篡改性。

#### 3.数据检索器（Indexer）

- ###### 智能合约通常以 Event 形式释放日志事件，比如释放代表 NFT 转移的 Transfer 事件，数据检索器会检索这些数据并将其写入到 PostgreSQL 等传统数据库中

- ###### Dapp 在前端进行数据展示时需要检索器内的数据

#### 	  4.区块链和去中心化存储（Blockchain & Decentralized Storage）

- ###### 区块链用于存储智能合约的状态数据及交易记录。去中心化存储IPFS，用于存储大规模的非结构化数据（如图片、文档等），确保数据不易丢失和篡改。

### 2.Dapp开发流程

#### 1.需求分析与规划

- ######  	

- **选择区块链平台**：决定在哪个平台上构建 Dapp（如以太坊、Solana、Polygon 等），这通常取决于目标用户群、交易成本、可扩展性等因素。

- **设计用户体验（UX）**：定义 Dapp 的界面设计和交互流程，确保用户能够轻松使用应用并与区块链交互。

#### 2.智能合约开发

- **编写智能合约**：使用 Solidity 或其他智能合约语言编写合约，确保合约的功能满足需求分析中定义的要求。
- **编写测试用例**：为智能合约编写单元测试，确保合约逻辑正确、无漏洞。
- **审计和优化**：对合约进行安全审计，确保合约的安全性，避免常见漏洞（如重入攻击、整数溢出等）。

#### 3.检索器开发

- **确定功能需要的数据内容**: 前端使用的数据大部份都直接来自检索器，所以开发者需要确定前端工程师所需要的数据

- **编写检索器程序**: 目前主流的检索器框架，如 ponder 和 subgraph 都是用了 TypeScript 语言作为检索器的程序编写语言，开发者主要编写事件数据清理以及事件数据写入数据库的代码

- **部署和运维**: 编写程序完成后，一般使用 Docker 部署到云服务器中，当然目前很多检索器框架也提供 SaaS 服务，同时检索器作为一个常规的数据库应用需要运维

#### 4.前端开发

- **选择前端框架**：使用前端框架来构建 UI。前端将通过 JavaScript 与智能合约进行交互。

- **连接钱包**：通过集成 **MetaMask** 等 Web3 钱包，用户可以连接到 Dapp，并授权其与智能合约交互。
- **显示区块链数据**：前端需要从区块链和检索器内获取数据（如账户余额、交易记录），并通过用户界面展示。
- **处理交易签名与确认**：当用户发起交易时，前端需要与钱包进行交互，获取用户的签名并将交易发送到区块链

#### 5.与区块链交互

- **读取数据**：前端通过智能合约的公共函数读取区块链上的状态数据（如余额、合约信息）。
- **发送交易**：当用户发起交易时，前端需要通过钱包签署交易并发送到区块链，执行合约中的某个功能（如转账）。

#### 6.部署与上线

- **部署智能合约**：推荐使用 **Hardhat** 或 **Foundry**（现代化开发工具）将智能合约部署到测试网（如 **Sepolia**、**Holesky**）或主网。

- **前端部署**：将前端应用部署到去中心化平台（如 **IPFS**）或传统的 Web 服务（Vercel）。
- **发布和维护**：将 Dapp 上线，进行用户反馈收集，定期更新合约和前端，修复潜在问题。

# 2025-08-12

完成简易投票Dapp

# 2025-08-11

1.参加以太坊周会
2.完成ethernaut任务打卡

# 2025-08-09

###
1.上午参加LXDAO会议
###
2.复习《Web3实习手册》智能合约开发 章节
###
  (1)更加熟悉一个智能合约开发，从创建到部署至Sepolia网络的流程

(2)熟悉前端与合约交互流程
* 前端调用API
* 请求用户授权访问钱包
* 实例化合约
* 钱包对交易进行签名
* 将签名交易发送到区块链
* 将交易结果更新到前端界面

# 2025-08-08

#
1.使用Remix IDE，在Sepolia测试网上发布NFT

# 2025-08-07

#
1.在My First NFT mint 第一个NFT

# 2025-08-06

#
1.创建MetaMask钱包，并转测试币给同学
2.Web3实习手册—了解web3行业知识
3.看助教老师8月5号晚会议回放
4.参加助教老师晚上会议

# 2025-08-05

#
完成Web3实习手册—入门导读

# 2025-08-04

#
1.web3工具安装
2.完成学分登记
3.参加助教线上会议

# 2025.07.31


<!-- Content_END -->
