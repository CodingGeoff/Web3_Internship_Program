---
timezone: UTC+8
---

# lilith998

**GitHub ID:** lilith998

**Telegram:** @无

## Self-introduction

大家好

## Notes

<!-- Content_START -->
# 2025-08-11

## **Uniswap V4 合约需求描述**

### 1. **项目背景**

Uniswap 是去中心化交易所（DEX），采用 AMM（自动做市商）模型，用户可无需订单簿进行代币兑换。
V4 目标：

* 降低部署成本（单合约多池）
* 提供 Hooks（钩子机制）以支持定制化逻辑
* 支持更广泛的交易与流动性策略

---

### 2. **核心需求**

#### **2.1 流动性池管理**

* 所有交易池由 `PoolManager` 合约统一管理
* 支持多种费率（例如 0.05%、0.3%、1%）
* 交易对可由任何 ERC20 代币或原生 ETH 组成
* 价格刻度基于 **tick**（固定间隔价格点）
* 池子状态需可查询（储备量、价格、手续费）

#### **2.2 流动性提供（LP）**

* 用户可在任意价格区间内提供流动性（集中流动性）
* 每个 LP 头寸为唯一 ID（可选 NFT 化）
* 系统需计算并记录 LP 的未领取手续费
* 允许部分或全部移除流动性

#### **2.3 交易（Swap）**

* 支持单跳（Single-hop）和多跳（Multi-hop）交易
* 使用恒定乘积公式或自定义 AMM 函数
* 可选择是否经过 Hooks 扩展逻辑（如收税、动态费率）
* 交易需防止滑点超出用户设定的限制

#### **2.4 Hooks 机制**

* 提供 `IHooks` 接口
* 钩子触发点：

  1. 添加流动性前/后
  2. 移除流动性前/后
  3. 交易前/后
* 外部开发者可部署自定义 Hooks，实现限价单、自动套利、费用分配等

#### **2.5 安全与合规**

* 防重入攻击（Reentrancy Guard）
* 防价格操纵（时间加权平均价格 TWAP）
* 针对闪电贷攻击的保护机制
* 事件日志（Events）用于交易、流动性、费率变更等记录

---

### 3. **合约结构**

主要合约：

1. **PoolManager.sol** - 管理池子、调用 Hooks、路由交易
2. **LiquidityPositions.sol** - 记录 LP 头寸、收益
3. **IHooks.sol** - Hooks 接口
4. **SwapMath.sol / TickMath.sol / Position.sol** - 数学运算与存储结构
5. **ERC20 接口** - 与代币交互
6. **Router（可选）** - 简化前端调用

---

### 4. **数据结构需求**

* **Pool**: `{token0, token1, fee, tickSpacing, liquidity, currentPrice, reserves}`
* **Position**: `{owner, poolId, tickLower, tickUpper, liquidity, feesOwed}`
* **SwapParams**: `{amountIn, amountOutMin, path, deadline}`

---

### 5. **非功能性需求**

* **Gas 优化**：使用紧凑存储（packed storage）、减少 SLOAD
* **可扩展性**：支持未来添加新 AMM 算法
* **可审计性**：清晰的事件日志和函数注释
* **兼容性**：支持 ERC20、ERC721、ETH

# 2025-08-10

以下是 Uniswap V4 合约架构的详细解析，涵盖核心合约、外围合约及其功能与核心流程，结合技术实现与设计创新进行系统性说明：

---

### 🧱 一、**核心合约（v4-core）**
#### **1. `PoolManager`（流动池管理单例合约）**
- **功能**：作为系统的中央管理者，统一处理所有流动性池的创建、交易、流动性调整等操作，替代了 V3 的工厂-池（Factory-Pool）模式。
- **核心流程**：
  - **池创建**：通过 `initialize` 函数创建新池，需传入 `PoolKey`（包含代币对、费率、钩子地址等参数）。
  - **交易路由**：支持多跳交易（Multi-hop Swaps），在单笔交易中跨多个池完成兑换，减少 Gas 消耗。
  - **锁机制（Lock）**：在执行关键操作前调用 `lock()`，确保原子性；结束时检查代币净余额（Token Delta）是否为0，防止资金不平衡。

#### **2. 核心库合约（Libraries）**
- **`Pool.sol`**：实现流动性池的核心逻辑，包括：
  - 头寸管理（`modifyPosition`）：添加/移除流动性，更新 Tick 区间和流动性深度。
  - 交易计算（`swap`）：基于集中流动性模型计算兑换数量和价格影响。
- **`Position.sol`**：管理流动性头寸数据，记录用户在不同价格区间的流动性份额，取消 V3 的 ERC-721 代币化设计，改为地址绑定存储。
- **`Hooks.sol`**：验证并执行钩子合约的逻辑，支持 8 个生命周期回调点（如 `beforeSwap`/`afterSwap`）。

#### **3. 数据类型与工具合约**
- **自定义值类型**：
  - `PoolId`：通过 `PoolKey` 哈希生成唯一池标识，类型为 `bytes32`。
  - `Currency`：代币地址的封装类型，支持比较操作（如 `>`、`==`）。
  - `BalanceDelta`：记录代币净余额变化（如 `amount0`/`amount1`），使用 `int128` 存储。
- **辅助合约**：
  - `Fees.sol`：管理协议手续费和动态费率逻辑。
  - `NoDelegateCall.sol`：禁止代理调用，增强安全性。

---

### 🔗 二、**外围合约（v4-periphery）**
#### **1. `PositionManager`（头寸管理器）**
- **功能**：为用户提供流动性头寸的创建、修改和销毁接口，封装与 `PoolManager` 的交互。
- **核心流程**：
  - **添加流动性**：调用 `modifyPosition`，指定价格区间和代币数量，更新头寸数据。
  - **头寸代币化（可选）**：通过 `mint` 生成 ERC-1155 凭证，代表流动性索取权，避免频繁代币转移。

#### **2. `V4Router`（路由合约）**
- **功能**：优化交易路径，支持单跳/多跳兑换，自动选择 V2/V3/V4 池的最佳价格。
- **核心流程**：
  - **路径计算**：使用 `PathKey` 库解析代币路径与池地址。
  - **代币转移**：通过 `settle`（存入代币）和 `take`（提取代币）完成最终结算。

#### **3. 钩子合约示例（Hooks Examples）**
- **`BaseHook.sol`**：钩子开发基础合约，需实现特定生命周期接口。
- **典型钩子应用**：
  - **`LimitOrder.sol`**：在 `afterSwap` 中触发限价单成交，将流动性添加到指定价格区间。
  - **`TWAMM.sol`**：拆分大额交易为小额订单，降低滑点。
  - **`DynamicFees.sol`**：根据波动率动态调整手续费。

---

### 🔄 三、**核心流程解析**
#### **1. 交易流程（Swap）**
1. **调用锁机制**：用户合约调用 `PoolManager.lock()`。
2. **执行交易**：在回调函数 `lockAcquired()` 中触发 `swap`，更新代币净余额（`TokenDelta`）。
3. **代币结算**：
   - `settle`：将输入代币转入池，减少 `TokenDelta` 正值。
   - `take`：从池中提取输出代币，减少 `TokenDelta` 负值。
4. **余额校验**：交易结束时若 `TokenDelta ≠ 0`，回滚交易。

#### **2. 流动性管理流程**
- **添加流动性**：  
  `PositionManager → modifyPosition → Pool.updatePosition`  
  更新 Tick 区间流动性，计算应存入的代币数量。
- **移除流动性**：  
  销毁 ERC-1155 凭证（若代币化），调用 `take` 提取代币。

# 2025-08-08

如何使用 **Foundry** 搭建一个类似 **Uniswap** 的 DApp 项目，重点拆解了智能合约的开发、部署和前端交互。以下是今天内容的总结：

---

### **1. Uniswap DApp 架构**

* **前端：** 使用 React.js 和 ethers.js 实现与智能合约的交互。
* **智能合约：** 采用 Solidity 编写，核心逻辑是基于 AMM 模型（如 `x * y = k`）来进行代币交换和流动性管理。
* **部署：** 智能合约部署到以太坊等区块链上，前端通过 Web3 技术（MetaMask 等）与合约进行交互。

### **2. 使用 Foundry 部署合约**

* **Foundry 介绍：** 一个快速的智能合约开发框架，提供了 `forge` 和 `cast` 两个工具来编译、测试和部署合约。
* **步骤：**

  1. 安装 Foundry。
  2. 初始化 Foundry 项目：`forge init`。
  3. 编写 Solidity 合约并使用 `forge build` 进行编译。
  4. 编写测试代码并使用 `forge test` 进行测试。
  5. 使用 `cast` 工具部署合约到以太坊测试网络（如 Rinkeby）。

### **3. 合约与前端交互**

* 使用 `ethers.js` 库在前端与部署的智能合约交互，实现例如流动性提供和代币交换的功能。
* 前端通过钱包（如 MetaMask）连接，并调用合约的相关函数。

# 2025-08-07

## 📚 今天的学习总结

### ✅ 一、前端从用户视角的分类：

前端可分为以下几类：

1. **网页前端**：浏览器中访问的常规网页（主要用于 DApp）
2. **移动端前端**：手机浏览器或 WebView 中的页面
3. **桌面端前端**：用 Electron 等技术构建的桌面应用
4. **小程序前端**：微信/支付宝等平台的专有应用
5. **智能设备前端**：IoT、车载、嵌入式等
6. **可视化大屏前端**：用于展示数据的大型看板界面

---

### ✅ 二、DApp 属于哪类前端？

* **主要是网页前端**（通过浏览器访问）
* **也可以适配移动端**（在钱包浏览器中打开）
* 偶尔用于桌面端（如钱包客户端）

---

### ✅ 三、DApp 前端典型用到的技术

1. **前端 UI 技术**：

   * React.js（推荐）或 Vue.js
   * Tailwind CSS、Chakra UI 等样式库

2. **Web3 区块链交互**：

   * `ethers.js`（主流库）
   * `wagmi` + `RainbowKit`（钱包连接更方便）
   * WalletConnect（移动钱包连接）
   * 与智能合约交互需使用 ABI + 合约地址

3. **环境/工具链**：

   * Vite、Node.js、VS Code、MetaMask
   * Hardhat/Remix（合约开发辅助）

# 2025-08-06

今天学的内容：以太坊生态；转账是怎么发生的；NFT与普通转账的区别；目前行业平台的分类；做什么的，怎么盈利，比较典型的组织名称。
心得：~~~~~~感觉在划水~~~~~~~~，好像没学到东西，我的学习方法？？有问题？？（开始自我怀疑）（鼓励自己）（督促自己）（快学！）

更新笔记如下：
https://onedrive.live.com/view.aspx?resid=B2EF29580F921137%21sd5e24162cc4f49c9b384657c83e4d5ae&id=documents

# 2025-08-04

？越靠后的区块包含以前的区块信息越来越多，那相应的越靠后的每一个区块的存储空间会不会越大
答：不会。每个区块的大小是有限且相对固定的；整个区块链的总存储需求
确实会随着新区块的增长而持续增长；后面区块间接依赖前面所有区块的完整性，但并不直接存储前面所有区块的完整数据。
知识点：区块的结构
	• 区块头：
	包含元数据，如区块版本、时间戳、难度目标、Nonce、前一个区块头的哈希值（这是链接的关键）、以及本区块所有交易的默克尔根哈希。区块头的大小是相对固定的（例如比特币区块头固定约80字节）。
	• 区块体：
	包含该区块打包的所有交易数据。这部分的大小是变化的，但通常有上限（如比特币最初约1MB，现在通过隔离见证等技术可扩容；以太坊则采用动态Gas限制来控制区块大小）。
如何验证本区块的有效性
计算上一区块的哈希，与本区块头中存储的weiw哈希比较。
未完待续，详见onenote笔记......


https://onedrive.live.com/view.aspx?resid=B2EF29580F921137%21sd5e24162cc4f49c9b384657c83e4d5ae&id=documents


# 2025.07.31


<!-- Content_END -->
