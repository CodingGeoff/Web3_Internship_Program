---
timezone: UTC+8
---

# 陈奕隆

**GitHub ID:** CYL12345

**Telegram:** @ElonCYL

## Self-introduction

我是WEB2转WEB3的开发学习者

## Notes

<!-- Content_START -->
# 2025-08-10

## 主要Gas优化措施

### 1. 内联汇编优化ETH转账

Blur在`_returnDust()`函数中使用内联汇编来返回剩余的ETH，这比标准的Solidity调用更节省gas

### 2. 批量订单处理

Blur支持批量签名验证机制，使用Merkle Tree来验证多个订单，这样可以在单次交易中处理多个订单，分摊gas成本 

### 3. 免Gas取消订单机制

通过Oracle Authorization机制，Blur实现了免gas取消Bid订单的功能。用户不需要发送链上交易来取消订单，只需要通过Blur的中心化服务器停止对订单的签名即可 

### 4. 优化的重入保护

使用`isInternal`标志和`setupExecution`修饰符来防止重入攻击，这比传统的重入锁更节省gas 

### 5. 高效的订单状态管理

通过`nonces`映射实现批量取消订单功能，用户只需调用一次`incrementNonce()`就能取消所有使用该nonce的订单，避免逐个取消的gas消耗 

### 6. 专用支付代币系统

BlurPool作为专门的支付代币，其`transferFrom()`函数只能被特定合约调用，减少了不必要的权限检查，提高了转账效率 

### 7. 内联汇编解析签名数据

在Oracle Authorization验证中，使用内联汇编直接从calldata中提取签名参数，避免了ABI解码的开销 。

# 2025-08-09

##### 构造调用数据
```
        bytes memory data = abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount);
        bytes memory returndata = token.functionCall(data);
```
    IERC20.transferFrom.selector
    这是 transferFrom（(address,address,uint256)的4字节函数选择器（function selector）。
    selector 是编译器自动生成的常量，等于
    bytes4(keccak256("transferFrom(address,address,uint256)"))

    abi.encodeWithSelector()
    ·把选择器和参数一起编码成ABI数据
    
#### 发起安全低级调用
```
bytes memory returndata = token.functionCall(data);
```
·token是ERC20合约地址
· funtionCall(data)是OpenZeppelin Address 库的一个扩展方法，内部：
    1、用call发起低级调用
    2、检查token是合约地址
    3、如果调用失败，会revert并返回异常信息
    4、返回合约的原始returndata
因为一些ERC20的代币实现并不标准，不会返回bool或者返回方式奇怪
使用functionCall 可以保证调用失败会revert 而不是返回false导致安全隐患
safeERC20也是如此实现

# 2025-08-08

## 核心验证流程

Blur的交易验证机制在`_execute()`方法中实现，包含以下关键步骤： 
### 1. 订单哈希计算与参数验证

系统首先计算买卖订单的哈希值，并验证订单参数的有效性： 

订单哈希通过`_hashOrder()`方法生成，结合订单数据和用户的nonce值：

### 2. 签名验证机制

Blur支持两种主要的签名验证方式： 

#### User Authorization
- **单一签名（Single）**：直接对订单哈希进行签名验证
- **批量签名（Bulk）**：使用Merkle Tree技术，允许用户一次签名多个订单 

#### Oracle Authorization  
这是Blur的创新功能，实现免gas取消订单： 

当订单的`extraParams[0] = 0x01`时，需要Oracle签名验证，这使得用户可以通过链下方式取消订单而无需支付gas费用。 

### 3. 订单匹配验证

通过`_canMatchOrders()`方法验证买卖订单是否可以匹配： 

系统会检查：
- 交易策略是否在PolicyManager白名单中
- 调用相应的MatchingPolicy进行具体匹配验证

### 4. 状态管理与防重放

验证通过后，系统将订单标记为已完成，防止重复执行： 

`cancelledOrFilled`映射记录已取消或已完成的订单，`nonces`映射支持批量取消用户所有订单。 [10](#0-9) 

## 安全保护机制

### 重入攻击防护
使用`isInternal`标志和`setupExecution`修饰符防止重入攻击： (#0-10) 

### 访问控制
- `isOpen`开关控制交易的开启和关闭
- 区块高度限制（`blockRange`）确保Oracle签名的时效性 

## Notes

Blur的验证机制设计巧妙地结合了链上安全性和链下便利性。特别是Oracle Authorization机制，通过链下服务器控制签名生成，实现了免gas取消订单的创新功能，这是Blur相比OpenSea等传统NFT交易平台的重要优势。系统支持三种交易策略：StandardPolicyERC721（普通和oracle版本）以及SafeCollectionBidPolicyERC721，分别服务于不同的交易场景。

# 2025-08-07

# blur的交易策略

### 数据结构
```
using EnumerableSet for EnumerableSet.AddressSet;
EnumerableSet.AddressSet private _whitelistedPolicies;
```
OpenZeppelin 的 EnumerableSet.AddressSet 存储白名单策略地址，这是一种高效的集合数据结构：
·确保地址唯一
·支持快速查询、添加、删除操作
·可枚举（查看所有白名单策略）

交易input : buy 和 sell
1、验证buy和sell的参数（order的参数和订单是否在取消列表内）
2、验证buy和sell的签名
（1）先验证订单是集合还是单独
    独立订单，将订单哈希转为EIR712格式哈希，再还原签名作对比
    集合订单，通过merkle树获得根节点，用根节点还原签名作对比


### 标准策略

#### StandardPolicyERC721 标准策略
比较买卖单建立时间，判断卖单和买单谁是挂单方，谁是吃单方，价格已挂单为准

### StandardPolicyERC721_1 Oracle标准
Oracle标准订单会有专门参数extraParams 如果有且第一个数据为"\x01"便是Orecle订单则需要Oracle签名，双重签名

### SafeCollectionBidPolicyERC721 
BID模式，买家对一个系列NFT出价，因此不会有卖单优先的情况，只能由卖家接受出价，这个模式不会校验tokenId

# 2025-08-06

## 我今天研究了blur交易平台的合约，了解其交易策略，根据策略2开一次交易所代码
## BID策略与普通策略的核心区别

在Blur系统中，主要有三种匹配策略，其中BID策略（`SafeCollectionBidPolicyERC721`）与普通策略有显著差异： [1](#9-0) 

### 1. 策略类型对比

**普通策略**：
- `StandardPolicyERC721`（normal）：支持常规NFT买卖交易
- `StandardPolicyERC721`（oracle）：支持Oracle授权的交易

**BID策略**：
- `SafeCollectionBidPolicyERC721`：专门用于Blur Bid功能

### 2. 核心功能差异

#### TokenId验证机制
BID策略最重要的特点是**不对tokenId进行校验**：

这意味着：
- 普通策略：必须指定具体的tokenId进行交易
- BID策略：可以使用`tokenId = 0`对整个collection进行出价

#### 方法支持差异
BID策略在方法支持上有严格限制： 

- `canMatchMakerBid()`：正常执行，支持买家出价场景
- `canMatchMakerAsk()`：直接revert，**不支持卖家挂单**

### 3. 实际应用场景

#### 普通策略应用
用于传统的NFT交易：
- 卖家挂单（listing）：指定具体tokenId和价格
- 买家购买：针对特定NFT进行购买

#### BID策略应用
专门用于Blur Bid功能： 

- 买家对整个collection出价，而非单个NFT
- 卖家可以接受任意符合条件的出价
- 支持无gas取消订单

### 4. 实际交易案例分析

在文档提供的Blur Bid交易案例中： 

可以看到：
- 使用`SafeCollectionBidPolicyERC721`策略
- `tokenId`设置为0（表示对整个collection出价）
- 需要Oracle授权（`extraParams = 0x01`）

### 5. 无Gas取消机制

BID策略结合Oracle授权实现了创新的无gas取消功能： 

- 普通策略：取消订单需要链上交易，消耗gas
- BID策略：通过停止Oracle签名即可取消，无需gas费用

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/token/ERC1155/IERC1155.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/utils/Base64.sol";

contract NFTVerificationRegistry is
    Initializable,
    Ownable2StepUpgradeable,
    ReentrancyGuardUpgradeable,
    PausableUpgradeable,
    AccessControlUpgradeable
{
    bytes32 public constant VERIFIER_ROLE = keccak256("VERIFIER_ROLE");
    bytes32 public constant OPERATOR_ROLE = keccak256("OPERATOR_ROLE");

    enum NFTType {
        ERC721,
        ERC1155
    }

    struct NFTInfo {
        address contractAddress;
        uint256 tokenId;
        address owner;
        string metadataUri;
        bytes32 metadataHash;
        NFTType nftType;
        bool isRegistered;
        bool isVerified;
        uint256 registerTime;
        uint256 lastUpdateTime;
        uint256 verificationTime;
    }

    //blacklist Prohibited NFT addresses for registration
    mapping(address => bool) public blacklistedContract;
    //contractId + tokenId => NFTinfo
    mapping(bytes32 => NFTInfo) public nftRegistry;
    // NFT address => NFT Account
    mapping(address => uint256) public registeredCount;

    event NFTRegistered(
        address indexed contractAddress,
        uint256 indexed tokenId,
        address indexed owner,
        NFTType nftType,
        string metadataUri,
        bytes32 metadataHash
    );

    event NFTVerified(
        address indexed contractAddress,
        uint256 indexed tokenId,
        address indexed verifier
    );

    event NFTOwnerUpdated(
        address indexed contractAddress,
        address indexed tokenId,
        address indexed oldOwner,
        address newOwner
    );

    event NFTMetadataUpdate(
        address indexed contractAddress,
        uint256 indexed tokenId,
        string oldMatedataUri,
        string newMateDateUri,
        bytes32 oldMatedataHash,
        bytes32 newMatedataHash
    );

    event ContractBlackList(address indexed contractAddress);
    event ContractWriteList(address indexed contractAddress);
    //Mark the completion of batch registration and count the number of registrations.
    event BatchRegistrationComplate(
        address indexed register,
        uint256 count,
        uint256 timestamp
    );

    //init && Grant deployment to all these roles
    function initialize() external initializer {
        __Ownable2Step_init();
        __ReentrancyGuard_init();
        __Pausable_init();
        __AccessControl_init();

        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(VERIFIER_ROLE, msg.sender);
        _grantRole(OPERATOR_ROLE, msg.sender);
    }

    modifier onlyVerifier() {
        require(hasRole(VERIFIER_ROLE, msg.sender), "not a verifier");
        _;
    }

    modifier onlyOperator() {
        require(hasRole(OPERATOR_ROLE, msg.sender), "not a operator");
        _;
    }

    /**
     * Returns a unique identifier for an NFT based on its contract address and token ID.
     * @param contractAddress The address of the NFT contract.
     * @param tokenId The token ID of the NFT.
     */
    function _getNFTKey(
        address contractAddress,
        uint256 tokenId
    ) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(contractAddress, tokenId));
    }

    /**
     * Computes the hash of the metadata URL.
     * @param metadataUri The URL of the NFT metadata to be hashed.
     */
    function _computeMetadataHash(
        string calldata metadataUri
    ) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(metadataUri));
    }

    function BatchRegistrationERC721(
        address contractAddress,
        uint256[] calldata tokenIds,
        string[] calldata metadataUris
    ) external whenNotPaused nonReentrant {
        require(contractAddress != address(0), "Invaild contract address");
        require(!blacklistedContract[contractAddress], "contract is blacklist");
        require(
            tokenIds.length != 0 && tokenIds.length == metadataUris.length,
            "Invalid input lengths"
        );
        require(
            IERC165(contractAddress).supportsInterface(
                type(IERC721).interfaceId
            ),
            "Not ERC721"
        );
        IERC721 nftContract = IERC721(contractAddress);
        uint256 registered = 0;

        for (uint256 i = 0; i < tokenIds.length; i++) {
            uint256 tokenId = tokenIds[i];
            bytes32 nftKey = _getNFTKey(contractAddress, tokenId);

            if (nftRegistry[nftKey].isRegistered) continue;

            address NFTowner = nftContract.ownerOf(tokenId);
            require(NFTowner != address(0), " NFT does not exist");

            nftRegistry[nftKey] = NFTInfo({
                contractAddress: contractAddress,
                tokenId: tokenId,
                owner: NFTowner,
                metadataUri: metadataUris[i],
                metadataHash: _computeMetadataHash(metadataUris[i]),
                nftType: NFTType.ERC721,
                isRegistered: true,
                isVerified: false,
                registerTime: block.timestamp,
                lastUpdateTime: block.timestamp,
                verificationTime: 0
            });

            registeredCount[contractAddress]++;
            registered++;

            emit NFTRegistered(
                contractAddress,
                tokenId,
                NFTowner,
                NFTType.ERC721,
                metadataUris[i],
                _computeMetadataHash(metadataUris[i])
            );
        }

        emit BatchRegistrationComplate(msg.sender, registered, block.timestamp);
    }

    function BatchRegistrationERC1155(
        address contractAddress,
        uint256[] calldata tokenIds,
        string[] calldata metadataUris
    ) external whenNotPaused nonReentrant {
        require(contractAddress != address(0), "Invaild contract address");
        require(!blacklistedContract[contractAddress], "contract is blacklist");
        require(
            tokenIds.length != 0 && tokenIds.length == metadataUris.length,
            "Invalid input lengths"
        );
        require(
            IERC165(contractAddress).supportsInterface(
                type(IERC1155).interfaceId
            ),
            "Not ERC721"
        );
        IERC1155 nftContract = IERC1155(contractAddress);
        uint256 registered = 0;

        for (uint256 i = 0; i < tokenIds.length; i++) {
            uint256 tokenId = tokenIds[i];
            bytes32 nftKey = _getNFTKey(contractAddress, tokenId);

            if (nftRegistry[nftKey].isRegistered) continue;

            require(
                nftContract.balanceOf(msg.sender, tokenId) > 0,
                "Caller does not own NFT"
            );

            nftRegistry[nftKey] = NFTInfo({
                contractAddress: contractAddress,
                tokenId: tokenId,
                owner: msg.sender,
                metadataUri: metadataUris[i],
                metadataHash: _computeMetadataHash(metadataUris[i]),
                nftType: NFTType.ERC721,
                isRegistered: true,
                isVerified: false,
                registerTime: block.timestamp,
                lastUpdateTime: block.timestamp,
                verificationTime: 0
            });

            registeredCount[contractAddress]++;
            registered++;

            emit NFTRegistered(
                contractAddress,
                tokenId,
                msg.sender,
                NFTType.ERC1155,
                metadataUris[i],
                _computeMetadataHash(metadataUris[i])
            );
        }

        emit BatchRegistrationComplate(msg.sender, registered, block.timestamp);
    }

    function registrationERC721(
        address contractAddress,
        uint256 tokenId,
        string calldata metadataUri
    ) external whenNotPaused nonReentrant {
        require(contractAddress != address(0), "Invaild contract address");
        require(!blacklistedContract[contractAddress], "contract is blacklist");
        require(tokenId > 0, "Invalid token ID");
        require(
            IERC165(contractAddress).supportsInterface(
                type(IERC721).interfaceId
            ),
            "Not ERC721"
        );
        IERC721 nftContract = IERC721(contractAddress);

        bytes32 nftKey = _getNFTKey(contractAddress, tokenId);

        require(!nftRegistry[nftKey].isRegistered, "NFT already registered");

        address NFTowner = nftContract.ownerOf(tokenId);
        require(NFTowner != address(0), " NFT does not exist");

        nftRegistry[nftKey] = NFTInfo({
            contractAddress: contractAddress,
            tokenId: tokenId,
            owner: NFTowner,
            metadataUri: metadataUri,
            metadataHash: _computeMetadataHash(metadataUri),
            nftType: NFTType.ERC721,
            isRegistered: true,
            isVerified: false,
            registerTime: block.timestamp,
            lastUpdateTime: block.timestamp,
            verificationTime: 0
        });

        registeredCount[contractAddress]++;

        emit NFTRegistered(
            contractAddress,
            tokenId,
            NFTowner,
            NFTType.ERC721,
            metadataUri,
            _computeMetadataHash(metadataUri)
        );
    }

     function registrationERC1155(
        address contractAddress,
        uint256 tokenId,
        string calldata metadataUri
    ) external whenNotPaused nonReentrant {
        require(contractAddress != address(0), "Invaild contract address");
        require(!blacklistedContract[contractAddress], "contract is blacklist");
        require(tokenId > 0, "Invalid token ID");
        require(
            IERC165(contractAddress).supportsInterface(
                type(IERC1155).interfaceId
            ),
            "Not ERC721"
        );
        IERC1155 nftContract = IERC1155(contractAddress);

        bytes32 nftKey = _getNFTKey(contractAddress, tokenId);

        require(!nftRegistry[nftKey].isRegistered, "NFT already registered");

        require(nftContract.balanceOf(msg.sender, tokenId)>0,"Caller does not own NFT");

        nftRegistry[nftKey] = NFTInfo({
            contractAddress: contractAddress,
            tokenId: tokenId,
            owner: msg.sender,
            metadataUri: metadataUri,
            metadataHash: _computeMetadataHash(metadataUri),
            nftType: NFTType.ERC1155,
            isRegistered: true,
            isVerified: false,
            registerTime: block.timestamp,
            lastUpdateTime: block.timestamp,
            verificationTime: 0
        });

        registeredCount[contractAddress]++;

        emit NFTRegistered(
            contractAddress,
            tokenId,
            msg.sender,
            NFTType.ERC1155,
            metadataUri,
            _computeMetadataHash(metadataUri)
        );
    }

    function verifyNFT(
        address contractAddress,
        uint256 tokenId
    ) external whenNotPaused onlyVerifier nonReentrant {
        bytes32 nftKey = _getNFTKey(contractAddress,tokenId);
        NFTInfo storage nftInfo = nftRegistry[nftKey];
        require(nftInfo.isRegistered,"NFT NO REGISTERED");
        require(!nftInfo.isVerified, "NFT already verified");

        nftInfo.isVerified = true;
        nftInfo.verificationTime = block.timestamp;
        nftInfo.lastUpdateTime = block.timestamp;

        emit NFTVerified(contractAddress,tokenId,msg.sender);
    }

    function batchUpdateOwners(
        address contractAddress,
        uint256[] calldata tokenIds,
        address[] calldata newOwners
    )external whenNotPaused onlyOperator nonReentrant{
        require(contractAddress!=address(0),"Invaild NFT address");
        require(tokenIds.length == newOwners.length,"Input length mismatch");

        for(uint256 i;i<tokenIds.length;i++){
              //_updateOwner(contractAddress, tokenIds[i], newOwners[i]);
        }
    }
}

```

# 2025-08-05

## Seaport订单结构概述

Seaport订单包含十一个核心组件，定义了完整的交易参数： 
## 核心订单组件

### 基本参数
- **offerer**: 订单发起者，提供所有offer物品的账户
- **zone**: 可选的二级账户，具有取消订单和验证受限订单的权限
- **orderType**: 订单类型，决定订单的填充方式和执行权限
- **startTime/endTime**: 订单的生效和过期时间戳
- **salt**: 订单的随机熵源
- **counter**: 必须匹配发起者当前计数器的值

### 物品数组
- **offer**: 发起者愿意提供的物品数组
- **consideration**: 为履行订单必须接收的物品数组

每个物品包含以下字段：
- `itemType`: 物品类型（Native/ERC20/ERC721/ERC1155/带条件的变体）
- `token`: 代币合约地址
- `identifierOrCriteria`: 代币ID或条件根
- `startAmount/endAmount`: 起始和结束数量（支持线性价格变化）

### 高级参数
- **zoneHash**: 传递给zone的32字节任意值
- **conduitKey**: 指定用于代币授权的conduit合约
- **totalOriginalConsiderationItems**: 原始consideration物品总数

## 订单类型分类

订单类型基于三个维度进行分类： 

1. **填充方式**:
   - `FULL`: 不支持部分填充
   - `PARTIAL`: 允许部分填充

2. **执行权限**:
   - `OPEN`: 任何账户都可以执行
   - `RESTRICTED`: 只能由发起者、zone或经zone批准执行

3. **生成方式**:
   - `CONTRACT`: 由合约动态生成的订单

## 物品类型支持

Seaport支持多种资产类型：

| 类型 | 枚举值 | 描述 |
|------|--------|------|
| NATIVE | 0 | 原生代币（ETH等） |
| ERC20 | 1 | 同质化代币 |
| ERC721 | 2 | 非同质化代币 |
| ERC1155 | 3 | 半同质化代币 |
| ERC721_WITH_CRITERIA | 4 | 带条件的ERC721 |
| ERC1155_WITH_CRITERIA | 5 | 带条件的ERC1155 |

## 批量订单结构

对于批量订单，Seaport使用树状结构来组织多个订单：
批量订单的JavaScript类型定义展示了完整的嵌套结构，包括：
- `BulkOrder`: 包含订单树的顶层结构
- `OrderComponents`: 单个订单的所有组件
- `OfferItem/ConsiderationItem`: 物品的详细规格

## 订单验证和哈希

订单通过以下方式进行验证：

系统将OrderParameters转换为OrderComponents（添加counter），然后计算订单哈希用于签名验证。

# 2025-08-04

# BLUR 交易所学习笔记
blur 这是一个建立在ETH上的非同质化代币（NFT）去中心化交易平台
### 特色功能
1、创新竞拍机制
2、高效的交易费用
3、聚合交易功能

### 数据结构
```
// 交易方向
enum Side { Buy, Sell }
// 签名类型
enum SignatureVersion { Single, Bulk }
// 资产类型
enum AssetType { ERC721, ERC1155 }

// 收费详情
struct Fee {
    uint16 rate; // 比率
    address payable recipient; // 接收者
}

// 订单数据
struct Order {
    address trader; // 订单创建者
    Side side; // 交易方向
    address matchingPolicy; // 交易策略
    address collection; // 合约地址
    uint256 tokenId; // tokenId
    uint256 amount; // 数量
    address paymentToken; // 支付的代币
    uint256 price; // 价格
    uint256 listingTime; // 挂单时间
    /* Order expiration timestamp - 0 for oracle cancellations. */
    uint256 expirationTime; // 过期时间，oracle cancellations 的是 0
    Fee[] fees; // 费用
    uint256 salt;
    bytes extraParams; // 额外数据，如果长度大于 0，且第一个元素是 1 则表示是oracle authorization
}

// 订单和签名数据
struct Input {
    Order order; // 订单数据
    uint8 v; 
    bytes32 r;
    bytes32 s;
    bytes extraSignature; // 批量订单校验和 Oracle 校验使用的额外数据
    SignatureVersion signatureVersion; // 签名类型
    uint256 blockNumber; // 挂单时的区块高度
}

// 交易双方的数据
struct Execution {
  Input sell;
  Input buy;
}

```

### 订单执行流程
（BlurExchange.sol）
1、参数校验，确认卖单方向
2、计算订单哈希（买卖双方）、
3、验证订单参数
4、验证双方签名
5、验证订单是否匹配（ERC721 / ERC1155）
6、标记订单完成
7、转移NFT，再转移资金
8、发出事件

### 订单策略

1、标准ERC721
2  安全收藏BID策略 ：用于集合出价，买家可以购买集合中的任何一个NFT

### 签名验证

Blur两种验证机制
1、单一签名：用户对单个订单进行签名 
2、批量签名：通过merkle树，用户一次可以签名多个订单，将所有要签名的订单哈希通过merkle树聚合成一个根哈希，然后对根哈希进行签字
```

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

//简化的订单结构
struct Order{
    address trader;
    address nftContract;
    uint256 tokenId;
    uint256 price;
    uint256 deadline;
    bool isSellOrder;
}

//签名枚举类型
enum SignatureVersion{
    single,
    bluk
}

contract BulkSignatureDemo{
    
    /**
     * @dev 计算订单的哈希值
     * @param order 订单结构体
     * @return 订单的哈希值
     */
    function _getOrderHash(Order memory order) internal pure returns(bytes32){
        return keccak256(abi.encode(
            order.trader, 
            order.nftContract,
            order.tokenId,
            order.price,
            order.deadline,
            order.isSellOrder
        ));
    }

    function _hashToSign(bytes32 dataHash) internal pure returns(bytes32){
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", dataHash));
    }

    function _mergeHashes(bytes32 a,bytes32 b)internal pure returns(bytes32){
        return a<b?keccak256(abi.encodePacked(a,b)):keccak256(abi.encodePacked(b,a));
    } 

    function buildMerkleTree(Order[] memory orders) public pure returns(bytes32 root){
        require(orders.length>0,"order is empty");

        //计算所有叶子节点哈希
        bytes32[] memory leaves = new bytes32[](orders.length+1);
        for(uint i=0;i<orders.length;i++){
            leaves[i] = _getOrderHash(orders[i]);
        }
        return _buildMerkleTree(leaves);
    }

    function _buildMerkleTree(bytes32[] memory leaves) internal pure returns(bytes32){
        if(leaves.length == 1){
            return leaves[0];
        }

        bytes32[] memory newLeaves = new bytes32[]((leaves.length+1)/2);
         for (uint i = 0; i < newLeaves.length; i++) {
            uint j = i * 2;
            if (j + 1 < leaves.length) {
                newLeaves[i] = _mergeHashes(leaves[j], leaves[j + 1]);
            } else {
                newLeaves[i] = leaves[j];
            }
        }
        
        return _buildMerkleTree(newLeaves);
    }

    function getMerklePath(Order[] memory orders, uint256 index) public pure returns (bytes32[] memory path) {
        require(index < orders.length, "Index out of bounds");
        
        // 计算所有叶子节点哈希
        bytes32[] memory leaves = new bytes32[](orders.length);
        for (uint i = 0; i < orders.length; i++) {
            leaves[i] = _getOrderHash(orders[i]);
        }
        
        return _getMerklePath(leaves, index);
    }

     /**
     * @dev 从哈希数组计算Merkle路径
     */
    function _getMerklePath(bytes32[] memory leaves, uint256 index) internal pure returns (bytes32[] memory) {
        if (leaves.length == 1) {
            return new bytes32[](0);
        }
        
        bytes32[] memory path;
        uint256 pathIndex = 0;
        bytes32[] memory currentLeaves = leaves;
        
        while (currentLeaves.length > 1) {
            uint256 newLength = (currentLeaves.length + 1) / 2;
            bytes32[] memory newLeaves = new bytes32[](newLength);
            
            for (uint i = 0; i < currentLeaves.length; i += 2) {
                uint j = i / 2;
                if (i + 1 < currentLeaves.length) {
                    newLeaves[j] = _mergeHashes(currentLeaves[i], currentLeaves[i + 1]);
                    
                    // 记录路径
                    if (i == index || i + 1 == index) {
                        path = path.length == 0 ? new bytes32[](1) : new bytes32[](path.length + 1);
                        path[pathIndex] = i == index ? currentLeaves[i + 1] : currentLeaves[i];
                        pathIndex++;
                    }
                } else {
                    newLeaves[j] = currentLeaves[i];
                    
                    // 记录路径
                    if (i == index) {
                        path = path.length == 0 ? new bytes32[](1) : new bytes32[](path.length + 1);
                        path[pathIndex] = currentLeaves[i];
                        pathIndex++;
                    }
                }
            }
            
            index = index / 2;
            currentLeaves = newLeaves;
        }
        
        return path;
    }

    function _verifySignature(
        address signer,
        bytes32 hashTosign,
        uint8 v,
        bytes32 r,
        bytes32 s
    )internal pure returns(bool){
        address recoverdSigner = ecrecover(hashTosign,v,r,s);
        return recoverdSigner!= address(0) && recoverdSigner == signer;
    }

    function verifyOrder(
        Order memory order,
        SignatureVersion version,
        uint8 v,
        bytes32 r,
        bytes32 s,
        bytes calldata extraData
    ) external view returns(bool){
        require(block.timestamp>order.deadline,"Order expired");

        bytes32 hashToSign;

        if(version == SignatureVersion.single){
            bytes32 orderHash = _getOrderHash(order);
            hashToSign = _hashToSign(orderHash);
        }else{
            bytes32 orderHash = _getOrderHash(order);

            bytes32[] memory merklePath = abi.decode(extraData, (bytes32[]));
             // 计算根哈希
            bytes32 currentHash = orderHash;
            for (uint i = 0; i < merklePath.length; i++) {
                currentHash = _mergeHashes(currentHash, merklePath[i]);
            }
            hashToSign = _hashToSign(currentHash);
        }

        return _verifySignature(order.trader,hashToSign,v,r,s);
    }



    //辅助测试函数
    function createTestOrder(
        address trader,
        address nftContract,
        uint256 tokenId,
        uint256 price,
        uint256 deadline,
        bool isSellOrder
    ) public pure returns(Order memory){
         return Order({
            trader: trader,
            nftContract: nftContract,
            tokenId: tokenId,
            price: price,
            deadline: deadline,
            isSellOrder: isSellOrder
        });
    }

    //生成测试用例
      /**
     * @dev 生成测试用的订单数组
     */
    function createTestOrders(address trader, address nftContract) external view returns (Order[] memory) {
        Order[] memory orders = new Order[](3);
        uint256 deadline = block.timestamp + 86400; // 24小时后过期
        
        orders[0] = createTestOrder(trader, nftContract, 1, 1 ether, deadline, true);
        orders[1] = createTestOrder(trader, nftContract, 2, 2 ether, deadline, true);
        orders[2] = createTestOrder(trader, nftContract, 3, 3 ether, deadline, true);
        
        return orders;
    }
}
```


注：还有一个oracle1授权机制，用于链下取消订单

### 订单取消机制
1、单个取消:调用 cancelOrdel 将订单标记为取消
2、批次取消
3、增加nonce：增加用户NONCE使用户所有先前的订单无效

### 资产和资金转移
1、资金转移：支持ETH和WETH支付，通过_transferTo和_transferFees函数处理
2、NFT转移：通过ExecutionDelegate代理合约处理NFT的转移，支持ERC721和ERC1155
3、blur pool： 类似WETH的ETH池，只能由BlurExchange和BlurSwap调用转账


# 2025.07.29


<!-- Content_END -->
