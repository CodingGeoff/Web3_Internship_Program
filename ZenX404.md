---
timezone: UTC+8
---

# ZenX

**GitHub ID:** ZenX404

**Telegram:** @ZenX404

## Self-introduction

金融企业程序猿一枚，四年web2开发经验。正在转型web3中...

## Notes

<!-- Content_START -->
# 2025-08-10

在 Solidity 中 constant、view、pure 三个函数修饰词的作用是告诉编译器，函数不改变 / 不读取状态变量，这样函数执行就可以不消耗 gas 了（是完全不消耗！），因为不需要矿工来验证，所以用好这几个关键词对省 gas 很重要。
	• constant: 常量，不可更改
	• view: 可读取但不可更改合约中的状态变量。能读取全局变量、不能修改全局变量、不会消耗Gas。
	• pure: 不可读取且不可更改合约中的状态变量。能读取全局变量、不能修改全局变量、不会消耗Gas。
据说，在 Solidity v4.17 之前，只有 constant，后来有人嫌 constant 这个词本身代表变量中的常量，不适合用来修饰函数，所以将 constant 拆成了 view 和 pure。view 的作用和 constant 一模一样，可以读取状态变量但是不能改；pure 则更为严格，pure 修饰的函数不能改也不能读状态变量，否则编译通不过。
所以一般用constant修饰常量，view和pure修饰函数。

# 2025-08-09

今天部署了ERC20 Token合约，并部署了BankToken合约，使用Next.js+viem为合约搭建了前端页面，实现了连接钱包，存款取款等功能

# 2025-08-08

区块链和链表最大的区别就是区块链用哈希指针代替了普通指针。

链表的指针就是指向一个结构体在内存中的地址，而哈希指针除了记录这一个区块的地址外，还会记录这个区块的哈希值（这个哈希值是整个区块所有数据进行哈希得到的），这样就能更方便的验证这个区块是否被篡改过（如果被篡改过，那么哈希值肯定就和以前的不一样了）。

第一个区块就是创世纪块，新创建出来的区块会被追加在最后，每一个区块有一个指向前序节点哈希指针。

基于区块链的这种结果，实现了通过其中一个区块的哈希值，就能推算出任何区块的哈希值是否被篡改（防止数据篡改），每一个区块的哈希值是根据自己以及前面的区块计算得来的。因为只要有一个恶意节点篡改了其中一个节点的数据，这个结点哈希值变了，那么连带着后面的所有结点哈希值都要跟这变，牵一发而动全身，这也就给了我们验证的条件。

比特币中的另外一个数据结构就是Merkle tree，他和binary tree（二叉树）的一个区别就是用哈希指针代替了普通指针。

每个区块之间是通过链表组织起来的，而每个区块内部会存储很多交易数据块（tx）。这些区块内部的交易数据块是通过Merkle tree组织起来的。Merkle tree的叶子节点就是交易数据块，上面的都是哈希指针节点，存储的是哈希指针。同样的道理，我们只要是有了根哈希指针（root hash index），我们就能判断出链上的数据区块的数据是否被篡改（因为只要是有一个区块发生了变化，那么根哈希指针肯定也会变化），并且通过Merkle tree的结构，使得查询速度有了很大提高。

只要记住根哈希值，就能检测树中任何部位的修改，如某个交易数据块修改会传导至根节点使根哈希值变化。

那比特币区块链的组织形式到底是以链表的形式，还是树的形式呢？
在比特币中，区块链的组织形式本质上是链表结构，但同时结合了默克尔树（Merkle Tree）这一树状结构来处理交易数据，二者相互配合，共同为区块链的运行提供支持。 
	• **链表形式**：区块链由一个个区块组成，这些区块之间通过哈希指针依次连接，形成了类似链表的结构。其中，最前面的是创世纪块，最后面的是最新产生的区块。每个区块的哈希指针是根据前面整个区块的内容计算得出的。这种链表结构使得区块链具有抗时间篡改的特性，任何对前面区块内容的修改，都会导致后续所有区块的哈希指针发生变化，从而被轻易检测到。例如，若有人修改了中间某个区块的内容，那么该区块的哈希值会改变，这会使得下一个区块中指向它的哈希指针不再匹配，并且这种影响会像多米诺骨牌一样传递到后续所有区块，最终导致系统中保存的最后一个区块的哈希值也发生变化 。 
	• **树的形式（默克尔树）**：在每个区块内部，交易数据是通过默克尔树来组织的。默克尔树底层的叶节点是一个个交易数据块，上层的内部节点都是哈希指针。这些哈希指针是由下层相邻数据块的哈希值拼接后再取哈希得到的，层层向上直至根节点，根节点的哈希值保存在区块头（block header）中。默克尔树的主要作用是提供默克尔证明（Merkle Proof），用于验证交易是否存在于区块中。比特币节点分为全节点和轻节点，全节点保存整个区块的内容，包括交易的具体信息；轻节点只保存区块头（比如我们本地下载的钱包，就只保存轻节点数据，用于验证交易数据），当轻节点需要验证某个交易时，全节点会提供从交易所在叶节点到根节点路径上的哈希值，轻节点通过计算这些哈希值来验证交易是否存在 。 

区块链的整体数据结构如下：各个区块用哈希指针连接，默克尔树的根哈希值存于区块头（block header），区块头无交易具体内容，交易列表存于区块体（block body），区块体就存储了默克尔树的结构。

我们本地下载的钱包只会存储轻节点，轻节点只存储了区块头（block header），区块头中存储了交易所在的默克尔树的根哈希值，但并没有存储区块链上的交易数据本身。

假设存在一个轻节点，该轻节点仅保存了 Merkle 树的根哈希值（存于区块的 block header 中），没有保存交易列表及 Merkle 树的具体内容。此时，轻节点想要验证某一特定交易（PPT 中标为黄色的交易）是否存在于区块中。

轻节点会向某个全节点发出请求（某一台矿工机器），全节点收到请求后，将图中标为红色的三个哈希值发送给轻节点。轻节点在接收到这些哈希值后，在本地进行计算。首先计算黄色交易自身的哈希值（图中标为绿色），然后将该绿色哈希值与全节点提供的相邻红色哈希值进行拼接，通过计算得出上一层节点中的绿色哈希值。按照这样的方式，继续将新得到的绿色哈希值与相邻红色哈希值拼接计算，进而算出再上一层的绿色哈希值，直至计算出整棵 Merkle 树的根哈希值。

最后，轻节点将计算得到的根哈希值与自身保存的 block header 里的根哈希值进行比较，以此来判断黄色交易是否存在于该 Merkle 树中，即是否存在于对应的区块里 。如果两者一致，则表明该交易在对应的区块中。

一、区块头和区块体与默克尔树的关系
	1. 结构组成：在比特币的每个区块中，分为区块头（block header）和区块体（block body）两部分。
	2. 默克尔树根哈希值存储位置：默克尔树的根哈希值存放在区块头中。这一设计至关重要，因为区块头包含的是与整个区块相关的关键元数据，根哈希值作为默克尔树的关键标识，放在此处可用于快速验证整个区块内交易数据的完整性。而区块头并不包含交易的具体内容，这使得其数据量相对较小，便于节点存储和传输 。
	3. 区块体的交易列表：区块体则存放着该区块内的交易列表。这些交易作为默克尔树的叶节点数据，通过层层计算哈希值构建出完整的默克尔树结构。每个交易在区块体中都有其对应的记录，是区块链交易信息的具体承载部分。
二、默克尔证明详解
	1. 证明的作用：默克尔证明（Merkle Proof）主要用于在比特币网络中，让轻节点能够高效验证某个交易是否存在于特定区块中。由于轻节点只保存区块头，缺乏完整的交易列表信息，默克尔证明提供了一种可靠的验证方式。
	2. 证明过程
		○ 请求与响应：当轻节点想要验证某个交易时，会向全节点发出请求。全节点收到请求后，会将从该交易所在叶节点到根节点路径上的哈希值发送给轻节点。
		○ 本地计算验证：轻节点收到这些哈希值后，在本地进行计算。首先计算该交易本身的哈希值，然后将其与全节点提供的相邻哈希值依次拼接并计算新的哈希值，按照默克尔树的构建规则层层向上计算，直至得到根哈希值。最后，将计算出的根哈希值与自己保存的区块头中的根哈希值进行比较。
		○ 验证原理：如果两个根哈希值一致，根据默克尔树的特性，即树中任何一个部位的修改都会导致根哈希值变化，就可以证明该交易确实存在于这个区块中。因为如果交易不存在或被篡改，计算出的根哈希值必然会与区块头中的根哈希值不同 。
	3. 安全性讨论：在验证过程中，虽然轻节点只能验证交易所在分支的哈希值，但篡改交易数据并使验证通过的难度极大。因为即使修改了交易内容，想要通过调整旁边不用验证的哈希值来保持整个节点的哈希值不变，这在实际中是不可行的，属于人为制造哈希碰撞，而哈希函数的抗碰撞性保证了这种操作几乎无法实现。
	4. 复杂度分析：从复杂度角度来看，若底层有 n 个交易，默克尔证明的时间和空间复杂度都是对数级别的。这意味着随着交易数量的增加，验证所需的时间和空间增长速度较慢，是一种高效的验证方式。对于证明交易不存在，如果不对叶节点排序，需要验证整个树，复杂度为线性；若对叶节点按交易哈希值排序，可通过提供相邻交易到根节点的路径证明，复杂度为对数级，但比特币中由于没有证明交易不存在的硬性需求，默克尔树不要求排序 。

比特币中的两种基本结构 —— 区块链和默克尔树，都是用哈希指针构造。比特币并不要求默克尔树的叶子节点是有序的，因为比特币中没有证明交易不存在的需求。同时指出，只要数据结构无环，都可用哈希指针代替普通指针，有环结构会出现循环依赖问题。

# 2025-08-07

代币发行与交易行为的法律风险

当前，中国法律明令禁止任何单位或个人通过 ICO、IEO、IDO 等方式进行融资活动。不论代币是否命名为“积分”“凭证”或“治理 Token”，只要具备融资功能或可流通性，即可能构成非法金融行为。

例如，一些项目通过“空投”或“白名单”的方式分发代币，实质上仍是面向公众筹资。一旦筹资规模扩大，项目方将可能被追究非法吸收公众存款罪。

技术人员若参与代币模型设计、空投逻辑配置、合约部署等环节，也会被视为“共同行为人”，无法以“只是写代码”为由免责。

赌博、传销、洗钱等刑事风险

Web3 项目的设计与经济激励模型直接影响风险等级。例如，部分链游存在“充值—抽奖—提现”的闭环结构，玩家投入法币或 USDT 购买盲盒、转盘机会，随机获得稀有 NFT 或 Token，后续可在平台提现或转售。这种“下注—随机收益—兑现”的机制容易被认定为开设赌场罪。

NFT 项目、DAO 社群、挖矿平台中常见的“邀请返利”“算力挂靠”“多级推广”模式，一旦涉及团队计酬、多层级返佣，可能触犯组织、领导传销活动罪。

场外交易中的洗钱与非法经营风险

虚拟货币在场外交易环节常被用作规避监管的“地下换汇”工具。境内个人先用人民币购买 USDT、ETH 等虚拟币，再通过链上或境外平台兑换美元、欧元等外币，形成跨境资金流转链条。此过程不仅绕过外汇监管，还使虚拟货币成为规避外汇管制的“桥梁资产”。根据《外汇管理条例》和刑法，未经许可反复组织撮合人民币与外币的虚拟币交易，可能构成非法经营外汇业务。

更为严重的是，部分交易对手或资金来源与电信诈骗、赌博、毒品交易等犯罪活动相关，参与者极有可能被控洗钱罪、掩饰隐瞒犯罪所得罪，甚至在不知情的情况下被卷入“协助洗钱”的刑事链条。因此，在参与虚拟币兑换时必须谨慎，对交易对手的信息、背景、资金来源进行审核，避免成为非法资金链条中的一环。

民商事争议

在 Web3 生态中，虚拟货币买卖、委托他人投资是常见的交易形式。根据我国目前的政策态度和司法实践，这类交易大概率被认定无效，即风险自担。

以虚拟货币买卖为例，由于国家禁止虚拟货币作为法偿工具，涉及“币币交易”的合同，法院通常不予支持。因价格波动、对价不明、交付失败产生的纠纷，极可能遭遇“合同无效”或“法院不受理”的局面。

委托代投方面，投资人基于友情或信任接受他人资金代为投资，行情波动、投资亏损或资金去向不明时，即使双方无恶意，也可能被追究民事赔偿责任，甚至面临涉嫌非法经营或非法集资的法律风险。委托方应在建立代投关系前，明确权利义务、委托范围及投资限制，并妥善保留协议及操作凭证，实时监督资金流向和账户变动，防止出现“全权委托”后的管理真空。

受托方则必须严守权限，不得擅自扩大投资范围，例如仅授权操作现货时，禁止擅自进行杠杆或合约交易。同时，不应轻易接受陌生资金，或公开宣传接受公众的资金，避免因资金安全、投资亏损等引发风险事件。

# 2025-08-06

比特币用到了密码学中的哈希和签名两大技术：
	• 哈希函数应用在挖矿时的有效工作证明中（求解困难，但是验证简单）。hash(e) < target，只等通过暴力方法去求解符合要求的哈希入参。
	• 比特币系统中创建一个账户、转账收款就会用到签名技术。


挖矿的有效工作证明
区块链是由一个个区块构成的，其实就相当于一个链表。比特币的区块链中每一个区块上会有一块空间专门用来存放一个数据，比特币中要求将这一个数据采用SHA-256哈希函数处理后，得到的结果应该小于一个目标值target。但是想要知道某一个值经过哈希后的结果是不是小于目标值，目前没有捷径的方法，只能暴力一个个试，这一点是哈希函数性质决定的。所以矿工节点本身是为了创建区块，来维护区块链的运行，而作为回报区块链会奖励矿工虚拟币，但是如何证明矿工确实有好好的工作（挖矿），这就需要有效工作证明，也就是前面说的必须要创建区块中的某一个数据哈希后小于目标值。这种方法的特点就是求解的时候会很困难，只能暴力地遍历求解（这就是为什么挖矿需要很多高性能显卡持续不断地进行运算，因为想要创建合法的区块，就必须保证哈希后的值小于target，所以就要遍历尝试出符合条件的入参是多少），但是验证起来却很简单，直接把他们计算出来的结果计算一次哈希就能直接判断是否符合要求了。这种特性就很适合作为有效工作证明。


签名技术
数字签名用来验证交易的合法性
	• 通讯时要把传输的数据进行加密，加密用的是通讯对方的公钥（公钥不用保密，所有人都可以知道），对方收到加密的信息后再用自己的私钥解密（加密和解密用的是同一个人的公钥和私钥），这种形式就叫做非对称加密。
	• 对称加密就是加密和解密都用同一个密钥。


在比特币中如何证明这个交易是由你来操作的，这就需要我们生成一个电子签名。
比特币中创建账户，其实就是创建了一个公钥和私钥，公钥相当于银行账号，别人知道了你的公钥就可以给你转账，私钥相当于银行密码，你只要有私钥就能把账户中的钱转走。比如我给一个人转账10个BTC，如何证明这笔转账确实是我本人转出的，而不是某个人冒充我只是为了把我的钱偷走而伪造的呢？我们在转账的时候就用自己的私钥对这一笔交易进行加密，然后把这一笔交易数据写入区块链上，大家都能够看到，其他人就可以用我的公钥来对区块链上的这一笔转账数据来解密，进而确定这一笔交易确实是由我本人发起的，这个私钥加密公钥解密的过程就是签名。这就是签名在比特币中的作用。

Bob想要进行交易，Bob先对自己要发送的交易数据Message用Hash函数做一次哈希，然后再用自己的私钥对哈希进行加密（椭圆曲线数字签名算法 ECDSA），加密后的密文我们就称为电子签名。然后就会把要发送的Message和这个电子签名发送到网络中，所有人都可以查看。Alice想要证明这笔交易是不是由Bob发出的，那么她就会去访问这个电子签名，用Bob的公钥对电子签名进行解密，得到Message的哈希值，然后再去用网络中的Message做一次哈希，对比这两个哈希值结果是否一样，如果一样，就说明这笔交易是Bob发出的。（只能用私钥进行数据加密，公钥只能用来解密数据）。所以私钥很重要，因为私钥可以伪造你的电子签名，就可以把你的资产全部转走。


所以虽然叫加密货币，但是除了私钥之外，其实链上所有信息都是公开的。

理论上讲，如果一个人不断地去创建账户，生成公私钥，然后把公钥和公链上的某一个公钥去比对，如果发现两个公钥是一样的，那么这个人就能用对应的私钥去盗取别人账户上的资产，将其转给自己的账户。但是实际操作上，其实是很难实现的，现在公钥256位，生成两个相同公钥的概率是微乎其微的，比地球爆炸的概率还要低，几乎可以忽略不记。（当然有些人认为当量子计算机出来之后，就能分分钟暴力尝试出相同的公私钥签名，破解公私钥就成为了现实，虚拟货币体系也将瓦解。但是我认为如果真的有那一天，最先被破解的也是现有的银行金融体系）


哈希和签名可以结合起来用的，比特币系统中一般是先对message做一次哈希，然后再对哈希值做一次签名（签名就是用私钥进行加密），将签名后的数据发送出去，接收方再用公钥去解密。

# 2025-08-05

入职Web3工作前应重点审查项目是否合法。即便员工非主导方，若整体项目涉嫌非法金融活动，也可能被牵连调查。建议主动要求查阅项目白皮书、Token 分发机制、收益模型、是否面向中国大陆用户、是否含有返利结构、投资承诺等。

# 2025-08-04

1、以太坊概念
我觉得可以简单地把基于以太坊网络理解为一个去中心化的云服务平台，我们可以将自己的项目代码部署到区块链上去运行。
这台“云服务器”是去中心化的，并且永远不会停机（因为有大量矿机节点运行，有认可这个网络的人在运行这个区块链就不会停止）

2、dex
去中心化交易所的个中币都是以交易对（两种币组合在一起，交易的时候只能用这其中的一个币去买另一个币，不能用其他的币买）形式出现的，必须有A币和B币组合在一起的流动性池，有这两个币的恒定值乘机，才能实现A币与B币的交易，如果没有A币和C币组合在一起的流动性池，A币和C币只能通过中间流动性池去交易，比如A先换B，再用B换C。

恒定做市商公式 x*y=k（k为常数）
这个公式是AMM机制的底层基石。表示在某一个交易时刻，X和Y两种资产的总价值乘积要等于一个常量k。在某一个时间点内，流动性池的两个币数量是一定的，我们就需要让其总价值数满足x*y=k这个公式，以实现自动做市商模型。


# 2025.07.29


<!-- Content_END -->
