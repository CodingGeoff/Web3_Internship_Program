---
timezone: UTC+8
---

# ZenX

**GitHub ID:** ZenX404

**Telegram:** @ZenX404

## Self-introduction

金融企业程序猿一枚，四年web2开发经验。正在转型web3中...

## Notes

<!-- Content_START -->
# 2025-08-17

1. 重入攻击 Reentrancy
	• 利用外部合约在 fallback 中重新调用原函数。历史上最著名的 The DAO 事件便因重入漏洞导致约 6000 万美元 ETH 被盗，最终造成以太坊社区分裂（形成 ETH/ETC 链）。
	• 防护方法：先更新状态，再转账。
	• 示例：
// ❌ 有漏洞
function withdraw() public {
    require(balance[msg.sender] > 0);
    (bool sent,) = msg.sender.call{value: balance[msg.sender]}("");
    require(sent);
    balance[msg.sender] = 0;
}

// ✅ 修复后
function withdraw() public {
    uint256 amount = balance[msg.sender];
    balance[msg.sender] = 0;
    (bool sent,) = msg.sender.call{value: amount}("");
    require(sent);
}
2. 预言机操纵 Oracle Manipulation
	• 依赖外部价格源的不可信更新。
	• 解决方法：
	• 使用 Chainlink 等权威价格源。
	• 增加时序约束和多源验证。
	• 使用 TWAP 等加权算法。
3. 整数溢出/下溢
	• 使用 unchecked {} 时需确保逻辑安全。
	• 推荐使用Solidity 0.8+ 的内建溢出检查或 SafeMath。
4. 权限控制缺失
	• 所有管理函数应使用 onlyOwner 或 AccessControl 修饰符保护。
5. 未初始化代理
	• 基于代理模式的合约若未正确执行初始化函数，可能被任意人初始化并接管合约。
	• 著名的例子包括 Harvest Finance 其在使用 Uniswap V3 做市策略的 Vault 合约中存在未初始化漏洞，如果被利用攻击者可销毁实现合约。该团队曾为此漏洞支付高额赏金修复。
6. 前置交易/三明治攻击
	• 攻击者在交易执行前后分别发送交易，以不利滑点或套利为目的。
	• 例如 2025 年 3 月，一名用户在 Uniswap V3 的稳定币兑换中遭遇三明治攻击，约 21.5 万美元的 USDC 兑换几乎被抢跑，损失了 98% 的资金>

# 2025-08-16

• 如果我们需要多次访问storage变量，并且还要对其进行修改的话，上面的这个优化方法就不合适了，因为上面的方法将storage读取到memory中，就算是修改memory变量，原本的storage变量也不会被修改（上面的方法适合只多次读取storage变量，但是不会对其进行修改的情况）。所以我们要用下面的优化方法：
		○ 未优化版本（每次都直接访问映射）：
		// 3次SLOAD操作，每次都要重新计算listings[_listingId]的存储位置
		require(listings[_listingId].isActive, "NFTMarket: listing is not active");
		require(listings[_listingId].seller == msg.sender, "NFTMarket: caller is not the seller");
		listings[_listingId].isActive = false;
		○ 优化版本（使用storage局部变量）：
		// 只需1次SLOAD操作获取指针，后续访问不需要额外SLOAD
		Listing storage listing = listings[_listingId];
		require(listing.isActive, "NFTMarket: listing is not active");
		require(listing.seller == msg.sender, "NFTMarket: caller is not the seller");
		listing.isActive = false;
		○ storage关键字创建了一个指向区块链状态存储中数据的引用（指针）。不会复制数据，而是直接操作原始存储位置，并不会重复计算存储位置。
		○ 在以太坊中，SLOAD（存储读取）操作是非常昂贵的（约800 gas），不使用局部变量时每次访问都会产生一次昂贵的SLOAD操作（3次独立读取）。
		○ 使用局部存储变量只需一次SLOAD操作获取结构体位置，之后对结构体字段的访问都通过这个引用进行，避免重复计算存储位置，特别是当多次访问同一个映射项的不同字段时更为高效

# 2025-08-14

在 Solidity 中，频繁读取 msg.sender 并不消耗额外的 Gas。msg.sender 是一个特殊全局变量，每次访问它时，它直接从执行上下文（execution context）中获取调用者的地址。这个操作本身非常高效，不会像读取存储变量（storage variables）那样涉及昂贵的存储I/O操作。

为什么读取 msg.sender 不消耗额外 Gas？
以太坊虚拟机（EVM）在处理交易时，会将交易的元数据（包括 msg.sender、msg.value、msg.data、block.timestamp 等）加载到内存中供合约访问。这些数据是每次交易或内部调用时自动可用的，访问它们基本上是免费的，或者说其Gas成本可以忽略不计，因为它不需要额外的计算或存储读取。

# 2025-08-12

使用constant关键字声明的常量可以节省Gas费，其值必须在编译时确定。
在 Solidity 中，使用 constant 关键字声明的常量可以节省 Gas 费，主要原因如下：
	1. 编译时确定：constant 关键字用于声明在编译时就能确定其值的变量。这意味着常量的值在合约部署时已经固定，不会在运行时改变。因此，编译器可以直接将常量的值嵌入到合约的字节码中。
	2. 减少存储操作：常量不需要存储在区块链的存储区中，因为它们的值在编译时已经确定并直接嵌入到合约中。这避免了对区块链存储的读写操作，而存储操作是区块链上最昂贵的操作之一。
	3. 优化合约执行：由于常量的值在编译时已知，合约在执行时不需要进行额外的计算或存储读取，这使得合约执行更高效，进而节省 Gas。
因此，使用 constant 关键字声明常量不仅可以提高合约的执行效率，还能显著降低合约的 Gas 成本。

在 Solidity 中，要实现编译时确定值，可以使用 constant 关键字来声明常量。常量的值必须在声明时就被赋予，并且不能在运行时改变。以下是一些实现编译时确定值的示例：
pragma solidity ^0.8.0;
contract ConstantsExample {
    // 使用 constant 关键字声明常量
    uint256 public constant MAX_SUPPLY = 1000000; // 最大供应量
    address public constant OWNER_ADDRESS = 0x1234567890abcdef1234567890abcdef12345678; // 合约所有者地址
    string public constant TOKEN_NAME = "MyToken"; // 代币名称

    // 函数示例
    function getMaxSupply() public pure returns (uint256) {
        return MAX_SUPPLY; // 返回常量值
    }
}

在这个示例中：
	• MAX_SUPPLY、OWNER_ADDRESS 和 TOKEN_NAME 都是常量，它们的值在声明时就被确定。
	• 这些常量的值在合约的字节码中直接嵌入，因此在合约执行时不需要进行存储读取或计算。
要确保值在编译时确定，常量的值必须是字面量或可以在编译时计算的表达式。不能依赖于运行时的输入或外部数据。

# 2025-08-11

Solidity中存储成本最高的变量类型是状态变量，其数据永久存储在区块链上。
在 Solidity 中，状态变量是合约中用于存储数据的变量，这些数据会永久存储在区块链上。状态变量的特点和作用如下：
	1. 永久存储：状态变量的数据存储在区块链的存储区中，这意味着它们在合约的生命周期内是持久的，即使合约执行结束后，数据仍然保留。
	2. 合约级别声明：状态变量是在合约中声明的，通常位于合约的最顶层，而不是在函数内部。
	3. 访问控制：状态变量可以有不同的访问控制修饰符（如 public、private、internal 和 external），这决定了它们的可见性和访问权限。
	4. Gas成本：由于状态变量的数据存储在区块链上，读写状态变量会消耗Gas，尤其是写操作，因为它需要更新区块链的状态。
	5. 初始化：状态变量在声明时可以被初始化，如果没有显式初始化，它们会被自动初始化为其默认值（如 0、false 或空字符串）。
	状态变量是智能合约中非常重要的组成部分，因为它们用于存储合约的关键数据和状态信息。

以下是一些使用状态变量的 Solidity 代码示例：
pragma solidity ^0.8.0;
contract ExampleContract {
    // 状态变量
    uint public count; // 一个无符号整数，默认值为0
    address public owner; // 存储合约所有者的地址
    string private secret; // 一个私有字符串变量

    // 构造函数，用于初始化状态变量
    constructor() {
        owner = msg.sender; // 将合约的部署者地址存储为所有者
        secret = "This is a secret"; // 初始化私有字符串
    }
    // 修改状态变量的函数
    function incrementCount() public {
        count += 1; // 增加count的值
    }
    // 读取私有状态变量的函数
    function getSecret() public view returns (string memory) {
        require(msg.sender == owner, "Only owner can view the secret");
        return secret; // 只有合约所有者可以读取secret
    }
}

# 2025-08-10

在 Solidity 中 constant、view、pure 三个函数修饰词的作用是告诉编译器，函数不改变 / 不读取状态变量，这样函数执行就可以不消耗 gas 了（是完全不消耗！），因为不需要矿工来验证，所以用好这几个关键词对省 gas 很重要。
	• constant: 常量，不可更改
	• view: 可读取但不可更改合约中的状态变量。能读取全局变量、不能修改全局变量、不会消耗Gas。
	• pure: 不可读取且不可更改合约中的状态变量。能读取全局变量、不能修改全局变量、不会消耗Gas。
据说，在 Solidity v4.17 之前，只有 constant，后来有人嫌 constant 这个词本身代表变量中的常量，不适合用来修饰函数，所以将 constant 拆成了 view 和 pure。view 的作用和 constant 一模一样，可以读取状态变量但是不能改；pure 则更为严格，pure 修饰的函数不能改也不能读状态变量，否则编译通不过。
所以一般用constant修饰常量，view和pure修饰函数。

# 2025-08-09

今天部署了ERC20 Token合约，并部署了BankToken合约，使用Next.js+viem为合约搭建了前端页面，实现了连接钱包，存款取款等功能

# 2025-08-08

区块链和链表最大的区别就是区块链用哈希指针代替了普通指针。

链表的指针就是指向一个结构体在内存中的地址，而哈希指针除了记录这一个区块的地址外，还会记录这个区块的哈希值（这个哈希值是整个区块所有数据进行哈希得到的），这样就能更方便的验证这个区块是否被篡改过（如果被篡改过，那么哈希值肯定就和以前的不一样了）。

第一个区块就是创世纪块，新创建出来的区块会被追加在最后，每一个区块有一个指向前序节点哈希指针。

基于区块链的这种结果，实现了通过其中一个区块的哈希值，就能推算出任何区块的哈希值是否被篡改（防止数据篡改），每一个区块的哈希值是根据自己以及前面的区块计算得来的。因为只要有一个恶意节点篡改了其中一个节点的数据，这个结点哈希值变了，那么连带着后面的所有结点哈希值都要跟这变，牵一发而动全身，这也就给了我们验证的条件。

比特币中的另外一个数据结构就是Merkle tree，他和binary tree（二叉树）的一个区别就是用哈希指针代替了普通指针。

每个区块之间是通过链表组织起来的，而每个区块内部会存储很多交易数据块（tx）。这些区块内部的交易数据块是通过Merkle tree组织起来的。Merkle tree的叶子节点就是交易数据块，上面的都是哈希指针节点，存储的是哈希指针。同样的道理，我们只要是有了根哈希指针（root hash index），我们就能判断出链上的数据区块的数据是否被篡改（因为只要是有一个区块发生了变化，那么根哈希指针肯定也会变化），并且通过Merkle tree的结构，使得查询速度有了很大提高。

只要记住根哈希值，就能检测树中任何部位的修改，如某个交易数据块修改会传导至根节点使根哈希值变化。

那比特币区块链的组织形式到底是以链表的形式，还是树的形式呢？
在比特币中，区块链的组织形式本质上是链表结构，但同时结合了默克尔树（Merkle Tree）这一树状结构来处理交易数据，二者相互配合，共同为区块链的运行提供支持。 
	• **链表形式**：区块链由一个个区块组成，这些区块之间通过哈希指针依次连接，形成了类似链表的结构。其中，最前面的是创世纪块，最后面的是最新产生的区块。每个区块的哈希指针是根据前面整个区块的内容计算得出的。这种链表结构使得区块链具有抗时间篡改的特性，任何对前面区块内容的修改，都会导致后续所有区块的哈希指针发生变化，从而被轻易检测到。例如，若有人修改了中间某个区块的内容，那么该区块的哈希值会改变，这会使得下一个区块中指向它的哈希指针不再匹配，并且这种影响会像多米诺骨牌一样传递到后续所有区块，最终导致系统中保存的最后一个区块的哈希值也发生变化 。 
	• **树的形式（默克尔树）**：在每个区块内部，交易数据是通过默克尔树来组织的。默克尔树底层的叶节点是一个个交易数据块，上层的内部节点都是哈希指针。这些哈希指针是由下层相邻数据块的哈希值拼接后再取哈希得到的，层层向上直至根节点，根节点的哈希值保存在区块头（block header）中。默克尔树的主要作用是提供默克尔证明（Merkle Proof），用于验证交易是否存在于区块中。比特币节点分为全节点和轻节点，全节点保存整个区块的内容，包括交易的具体信息；轻节点只保存区块头（比如我们本地下载的钱包，就只保存轻节点数据，用于验证交易数据），当轻节点需要验证某个交易时，全节点会提供从交易所在叶节点到根节点路径上的哈希值，轻节点通过计算这些哈希值来验证交易是否存在 。 

区块链的整体数据结构如下：各个区块用哈希指针连接，默克尔树的根哈希值存于区块头（block header），区块头无交易具体内容，交易列表存于区块体（block body），区块体就存储了默克尔树的结构。

我们本地下载的钱包只会存储轻节点，轻节点只存储了区块头（block header），区块头中存储了交易所在的默克尔树的根哈希值，但并没有存储区块链上的交易数据本身。

假设存在一个轻节点，该轻节点仅保存了 Merkle 树的根哈希值（存于区块的 block header 中），没有保存交易列表及 Merkle 树的具体内容。此时，轻节点想要验证某一特定交易（PPT 中标为黄色的交易）是否存在于区块中。

轻节点会向某个全节点发出请求（某一台矿工机器），全节点收到请求后，将图中标为红色的三个哈希值发送给轻节点。轻节点在接收到这些哈希值后，在本地进行计算。首先计算黄色交易自身的哈希值（图中标为绿色），然后将该绿色哈希值与全节点提供的相邻红色哈希值进行拼接，通过计算得出上一层节点中的绿色哈希值。按照这样的方式，继续将新得到的绿色哈希值与相邻红色哈希值拼接计算，进而算出再上一层的绿色哈希值，直至计算出整棵 Merkle 树的根哈希值。

最后，轻节点将计算得到的根哈希值与自身保存的 block header 里的根哈希值进行比较，以此来判断黄色交易是否存在于该 Merkle 树中，即是否存在于对应的区块里 。如果两者一致，则表明该交易在对应的区块中。

一、区块头和区块体与默克尔树的关系
	1. 结构组成：在比特币的每个区块中，分为区块头（block header）和区块体（block body）两部分。
	2. 默克尔树根哈希值存储位置：默克尔树的根哈希值存放在区块头中。这一设计至关重要，因为区块头包含的是与整个区块相关的关键元数据，根哈希值作为默克尔树的关键标识，放在此处可用于快速验证整个区块内交易数据的完整性。而区块头并不包含交易的具体内容，这使得其数据量相对较小，便于节点存储和传输 。
	3. 区块体的交易列表：区块体则存放着该区块内的交易列表。这些交易作为默克尔树的叶节点数据，通过层层计算哈希值构建出完整的默克尔树结构。每个交易在区块体中都有其对应的记录，是区块链交易信息的具体承载部分。
二、默克尔证明详解
	1. 证明的作用：默克尔证明（Merkle Proof）主要用于在比特币网络中，让轻节点能够高效验证某个交易是否存在于特定区块中。由于轻节点只保存区块头，缺乏完整的交易列表信息，默克尔证明提供了一种可靠的验证方式。
	2. 证明过程
		○ 请求与响应：当轻节点想要验证某个交易时，会向全节点发出请求。全节点收到请求后，会将从该交易所在叶节点到根节点路径上的哈希值发送给轻节点。
		○ 本地计算验证：轻节点收到这些哈希值后，在本地进行计算。首先计算该交易本身的哈希值，然后将其与全节点提供的相邻哈希值依次拼接并计算新的哈希值，按照默克尔树的构建规则层层向上计算，直至得到根哈希值。最后，将计算出的根哈希值与自己保存的区块头中的根哈希值进行比较。
		○ 验证原理：如果两个根哈希值一致，根据默克尔树的特性，即树中任何一个部位的修改都会导致根哈希值变化，就可以证明该交易确实存在于这个区块中。因为如果交易不存在或被篡改，计算出的根哈希值必然会与区块头中的根哈希值不同 。
	3. 安全性讨论：在验证过程中，虽然轻节点只能验证交易所在分支的哈希值，但篡改交易数据并使验证通过的难度极大。因为即使修改了交易内容，想要通过调整旁边不用验证的哈希值来保持整个节点的哈希值不变，这在实际中是不可行的，属于人为制造哈希碰撞，而哈希函数的抗碰撞性保证了这种操作几乎无法实现。
	4. 复杂度分析：从复杂度角度来看，若底层有 n 个交易，默克尔证明的时间和空间复杂度都是对数级别的。这意味着随着交易数量的增加，验证所需的时间和空间增长速度较慢，是一种高效的验证方式。对于证明交易不存在，如果不对叶节点排序，需要验证整个树，复杂度为线性；若对叶节点按交易哈希值排序，可通过提供相邻交易到根节点的路径证明，复杂度为对数级，但比特币中由于没有证明交易不存在的硬性需求，默克尔树不要求排序 。

比特币中的两种基本结构 —— 区块链和默克尔树，都是用哈希指针构造。比特币并不要求默克尔树的叶子节点是有序的，因为比特币中没有证明交易不存在的需求。同时指出，只要数据结构无环，都可用哈希指针代替普通指针，有环结构会出现循环依赖问题。

# 2025-08-07

代币发行与交易行为的法律风险

当前，中国法律明令禁止任何单位或个人通过 ICO、IEO、IDO 等方式进行融资活动。不论代币是否命名为“积分”“凭证”或“治理 Token”，只要具备融资功能或可流通性，即可能构成非法金融行为。

例如，一些项目通过“空投”或“白名单”的方式分发代币，实质上仍是面向公众筹资。一旦筹资规模扩大，项目方将可能被追究非法吸收公众存款罪。

技术人员若参与代币模型设计、空投逻辑配置、合约部署等环节，也会被视为“共同行为人”，无法以“只是写代码”为由免责。

赌博、传销、洗钱等刑事风险

Web3 项目的设计与经济激励模型直接影响风险等级。例如，部分链游存在“充值—抽奖—提现”的闭环结构，玩家投入法币或 USDT 购买盲盒、转盘机会，随机获得稀有 NFT 或 Token，后续可在平台提现或转售。这种“下注—随机收益—兑现”的机制容易被认定为开设赌场罪。

NFT 项目、DAO 社群、挖矿平台中常见的“邀请返利”“算力挂靠”“多级推广”模式，一旦涉及团队计酬、多层级返佣，可能触犯组织、领导传销活动罪。

场外交易中的洗钱与非法经营风险

虚拟货币在场外交易环节常被用作规避监管的“地下换汇”工具。境内个人先用人民币购买 USDT、ETH 等虚拟币，再通过链上或境外平台兑换美元、欧元等外币，形成跨境资金流转链条。此过程不仅绕过外汇监管，还使虚拟货币成为规避外汇管制的“桥梁资产”。根据《外汇管理条例》和刑法，未经许可反复组织撮合人民币与外币的虚拟币交易，可能构成非法经营外汇业务。

更为严重的是，部分交易对手或资金来源与电信诈骗、赌博、毒品交易等犯罪活动相关，参与者极有可能被控洗钱罪、掩饰隐瞒犯罪所得罪，甚至在不知情的情况下被卷入“协助洗钱”的刑事链条。因此，在参与虚拟币兑换时必须谨慎，对交易对手的信息、背景、资金来源进行审核，避免成为非法资金链条中的一环。

民商事争议

在 Web3 生态中，虚拟货币买卖、委托他人投资是常见的交易形式。根据我国目前的政策态度和司法实践，这类交易大概率被认定无效，即风险自担。

以虚拟货币买卖为例，由于国家禁止虚拟货币作为法偿工具，涉及“币币交易”的合同，法院通常不予支持。因价格波动、对价不明、交付失败产生的纠纷，极可能遭遇“合同无效”或“法院不受理”的局面。

委托代投方面，投资人基于友情或信任接受他人资金代为投资，行情波动、投资亏损或资金去向不明时，即使双方无恶意，也可能被追究民事赔偿责任，甚至面临涉嫌非法经营或非法集资的法律风险。委托方应在建立代投关系前，明确权利义务、委托范围及投资限制，并妥善保留协议及操作凭证，实时监督资金流向和账户变动，防止出现“全权委托”后的管理真空。

受托方则必须严守权限，不得擅自扩大投资范围，例如仅授权操作现货时，禁止擅自进行杠杆或合约交易。同时，不应轻易接受陌生资金，或公开宣传接受公众的资金，避免因资金安全、投资亏损等引发风险事件。

# 2025-08-06

比特币用到了密码学中的哈希和签名两大技术：
	• 哈希函数应用在挖矿时的有效工作证明中（求解困难，但是验证简单）。hash(e) < target，只等通过暴力方法去求解符合要求的哈希入参。
	• 比特币系统中创建一个账户、转账收款就会用到签名技术。


挖矿的有效工作证明
区块链是由一个个区块构成的，其实就相当于一个链表。比特币的区块链中每一个区块上会有一块空间专门用来存放一个数据，比特币中要求将这一个数据采用SHA-256哈希函数处理后，得到的结果应该小于一个目标值target。但是想要知道某一个值经过哈希后的结果是不是小于目标值，目前没有捷径的方法，只能暴力一个个试，这一点是哈希函数性质决定的。所以矿工节点本身是为了创建区块，来维护区块链的运行，而作为回报区块链会奖励矿工虚拟币，但是如何证明矿工确实有好好的工作（挖矿），这就需要有效工作证明，也就是前面说的必须要创建区块中的某一个数据哈希后小于目标值。这种方法的特点就是求解的时候会很困难，只能暴力地遍历求解（这就是为什么挖矿需要很多高性能显卡持续不断地进行运算，因为想要创建合法的区块，就必须保证哈希后的值小于target，所以就要遍历尝试出符合条件的入参是多少），但是验证起来却很简单，直接把他们计算出来的结果计算一次哈希就能直接判断是否符合要求了。这种特性就很适合作为有效工作证明。


签名技术
数字签名用来验证交易的合法性
	• 通讯时要把传输的数据进行加密，加密用的是通讯对方的公钥（公钥不用保密，所有人都可以知道），对方收到加密的信息后再用自己的私钥解密（加密和解密用的是同一个人的公钥和私钥），这种形式就叫做非对称加密。
	• 对称加密就是加密和解密都用同一个密钥。


在比特币中如何证明这个交易是由你来操作的，这就需要我们生成一个电子签名。
比特币中创建账户，其实就是创建了一个公钥和私钥，公钥相当于银行账号，别人知道了你的公钥就可以给你转账，私钥相当于银行密码，你只要有私钥就能把账户中的钱转走。比如我给一个人转账10个BTC，如何证明这笔转账确实是我本人转出的，而不是某个人冒充我只是为了把我的钱偷走而伪造的呢？我们在转账的时候就用自己的私钥对这一笔交易进行加密，然后把这一笔交易数据写入区块链上，大家都能够看到，其他人就可以用我的公钥来对区块链上的这一笔转账数据来解密，进而确定这一笔交易确实是由我本人发起的，这个私钥加密公钥解密的过程就是签名。这就是签名在比特币中的作用。

Bob想要进行交易，Bob先对自己要发送的交易数据Message用Hash函数做一次哈希，然后再用自己的私钥对哈希进行加密（椭圆曲线数字签名算法 ECDSA），加密后的密文我们就称为电子签名。然后就会把要发送的Message和这个电子签名发送到网络中，所有人都可以查看。Alice想要证明这笔交易是不是由Bob发出的，那么她就会去访问这个电子签名，用Bob的公钥对电子签名进行解密，得到Message的哈希值，然后再去用网络中的Message做一次哈希，对比这两个哈希值结果是否一样，如果一样，就说明这笔交易是Bob发出的。（只能用私钥进行数据加密，公钥只能用来解密数据）。所以私钥很重要，因为私钥可以伪造你的电子签名，就可以把你的资产全部转走。


所以虽然叫加密货币，但是除了私钥之外，其实链上所有信息都是公开的。

理论上讲，如果一个人不断地去创建账户，生成公私钥，然后把公钥和公链上的某一个公钥去比对，如果发现两个公钥是一样的，那么这个人就能用对应的私钥去盗取别人账户上的资产，将其转给自己的账户。但是实际操作上，其实是很难实现的，现在公钥256位，生成两个相同公钥的概率是微乎其微的，比地球爆炸的概率还要低，几乎可以忽略不记。（当然有些人认为当量子计算机出来之后，就能分分钟暴力尝试出相同的公私钥签名，破解公私钥就成为了现实，虚拟货币体系也将瓦解。但是我认为如果真的有那一天，最先被破解的也是现有的银行金融体系）


哈希和签名可以结合起来用的，比特币系统中一般是先对message做一次哈希，然后再对哈希值做一次签名（签名就是用私钥进行加密），将签名后的数据发送出去，接收方再用公钥去解密。

# 2025-08-05

入职Web3工作前应重点审查项目是否合法。即便员工非主导方，若整体项目涉嫌非法金融活动，也可能被牵连调查。建议主动要求查阅项目白皮书、Token 分发机制、收益模型、是否面向中国大陆用户、是否含有返利结构、投资承诺等。

# 2025-08-04

1、以太坊概念
我觉得可以简单地把基于以太坊网络理解为一个去中心化的云服务平台，我们可以将自己的项目代码部署到区块链上去运行。
这台“云服务器”是去中心化的，并且永远不会停机（因为有大量矿机节点运行，有认可这个网络的人在运行这个区块链就不会停止）

2、dex
去中心化交易所的个中币都是以交易对（两种币组合在一起，交易的时候只能用这其中的一个币去买另一个币，不能用其他的币买）形式出现的，必须有A币和B币组合在一起的流动性池，有这两个币的恒定值乘机，才能实现A币与B币的交易，如果没有A币和C币组合在一起的流动性池，A币和C币只能通过中间流动性池去交易，比如A先换B，再用B换C。

恒定做市商公式 x*y=k（k为常数）
这个公式是AMM机制的底层基石。表示在某一个交易时刻，X和Y两种资产的总价值乘积要等于一个常量k。在某一个时间点内，流动性池的两个币数量是一定的，我们就需要让其总价值数满足x*y=k这个公式，以实现自动做市商模型。


# 2025.07.29


<!-- Content_END -->
